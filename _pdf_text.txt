

===== PAGE 1 =====

Information Integration
Maurizio Lenzerini - Antonella Poggi
Dipartimento di Ingegneria Informatica Automatica e Gestionale Antonio Ruberti
Universit` a di Roma La Sapienza
Course: Large Scale Data Management A.Y. 2024/2025
Section: Information Integration
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (1/199)

===== PAGE 2 =====

Overview of the course
1Formalization of information integration
2Query answering and data exchange in the absence of constraints
Query answering in the Global-as-view (GAV) setting
Data exchange in the absence of constraints
Query answering in the Local-as-view (LAV) and GLAV setting
3Ontology-based data integration
Ontologies
Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (2/199)

===== PAGE 3 =====

Overview of the course
1Formalization of information integration
2Query answering and data exchange in the absence of constraints
Query answering in the Global-as-view (GAV) setting
Data exchange in the absence of constraints
Query answering in the Local-as-view (LAV) and GLAV setting
3Ontology-based data integration
Ontologies
Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (2/199)

===== PAGE 4 =====

Overview of the course
1Formalization of information integration
2Query answering and data exchange in the absence of constraints
Query answering in the Global-as-view (GAV) setting
Data exchange in the absence of constraints
Query answering in the Local-as-view (LAV) and GLAV setting
3Ontology-based data integration
Ontologies
Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (2/199)

===== PAGE 5 =====

Information integration: Logical formalization
Formalization of information integration
Outline of Part 1
1Information integration: Logical formalization
Syntax and semantics of an information integration system
Queries to an information integration system
Formalizing the mapping
Formalizing GAV information integration systems
Formalizing LAV information integration systems
Query answering in the various contexts
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (3/199)

===== PAGE 6 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Outline of Part 1
1Information integration: Logical formalization
Syntax and semantics of an information integration system
Queries to an information integration system
Formalizing the mapping
Formalizing GAV information integration systems
Formalizing LAV information integration systems
Query answering in the various contexts
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (4/199)

===== PAGE 7 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Formal framework for information integration
Definition
Aninformation integration system Iis a triple ⟨G,S,M⟩, where
Gis the global schema
i.e., a logical theory over a relational alphabet AG
Sis the source schema
i.e., simply a relational alphabet ASdisjoint from AG
Mis the mapping between SandG
We consider different approaches to the specification of mappings
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (5/199)

===== PAGE 8 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Semantics of an information integration system
Which are the dbs that satisfy I, i.e., the logical models of I?
We refer only to dbs over a fixed infinite domain ∆of elements
We have to take into account data present at the sources: these
are modeled through a (finite) source database Cover∆(also
called source model), fixing the extension of the predicates of AS
The dbs for Iare logical interpretations for AG, called global dbs
Definition
Theset of databases for AGthat satisfy Irelative to Cis:
semC(I) ={ B | B is a global database that satisfies G,
and that satisfies MwrtC }
To satisfy Gmeans to satisfy all axioms of G, i.e., being a model of G
What it means to satisfy MwrtCdepends on the nature of M
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (6/199)

===== PAGE 9 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Semantics of an information integration system
Which are the dbs that satisfy I, i.e., the logical models of I?
We refer only to dbs over a fixed infinite domain ∆of elements
We have to take into account data present at the sources: these
are modeled through a (finite) source database Cover∆(also
called source model), fixing the extension of the predicates of AS
The dbs for Iare logical interpretations for AG, called global dbs
Definition
Theset of databases for AGthat satisfy Irelative to Cis:
semC(I) ={ B | B is a global database that satisfies G,
and that satisfies MwrtC }
To satisfy Gmeans to satisfy all axioms of G, i.e., being a model of G
What it means to satisfy MwrtCdepends on the nature of M
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (6/199)

===== PAGE 10 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Relational calculus: Syntax
Definition
An(domain) relational calculus query over alphabet Ahas the form
{(x1, . . . , x n)|φ}
where
n≥0is the arity of the query
x1, . . . , x nare (not necessarily distinct) variables
φis the body of the query, i.e., a formula of LAwhose free
variables are exactly x1, . . . , x n
(x1, . . . , x n)is called the target list of the query
Ifris a predicate of arity k, anatom with predicate rhas the form
r(y1, . . . , y k), where y1, . . . , y kare variables or constants
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (7/199)

===== PAGE 11 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Conjunctive queries
are the most common kind of relational calculus queries
also known as select-project-join SQL queries
allow for easy optimization in relational DBMSs
Definition
Aconjunctive query (CQ) is a relational calculus query of the form
{(⃗ x)| ∃⃗ y.r1(⃗ x1, ⃗ y1)∧ ··· ∧ rm(⃗ xm, ⃗ ym)}
where
⃗ xis the union of the ⃗ xi’s, and ⃗ yis the union of the ⃗ yi’s
r1, . . . , r mare relation symbols (not built-in predicates)
We use the following abbreviation: {(⃗ x)|r1(⃗ x1, ⃗ y1), . . . , r m(⃗ xm, ⃗ ym)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (8/199)

===== PAGE 12 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Conjunctive queries
are the most common kind of relational calculus queries
also known as select-project-join SQL queries
allow for easy optimization in relational DBMSs
Definition
Aconjunctive query (CQ) is a relational calculus query of the form
{(⃗ x)| ∃⃗ y.r1(⃗ x1, ⃗ y1)∧ ··· ∧ rm(⃗ xm, ⃗ ym)}
where
⃗ xis the union of the ⃗ xi’s, and ⃗ yis the union of the ⃗ yi’s
r1, . . . , r mare relation symbols (not built-in predicates)
We use the following abbreviation: {(⃗ x)|r1(⃗ x1, ⃗ y1), . . . , r m(⃗ xm, ⃗ ym)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (8/199)

===== PAGE 13 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Complexity of relational calculus
We consider the complexity of the recognition problem , i.e., checking
whether a tuple of constants is in the answer to a query:
measured wrt the size of the database ;data complexity
measured wrt the size of the query and the database ;
combined complexity
Complexity of relational calculus
data complexity: polynomial, actually in LogSpace (or, in terms
of circuit complexity, in AC0)
combined complexity: PSpace -complete
Complexity of conjunctive queries
data complexity: in LogSpace
combined complexity: NP-complete
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (9/199)

===== PAGE 14 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Complexity of relational calculus
We consider the complexity of the recognition problem , i.e., checking
whether a tuple of constants is in the answer to a query:
measured wrt the size of the database ;data complexity
measured wrt the size of the query and the database ;
combined complexity
Complexity of relational calculus
data complexity: polynomial, actually in LogSpace (or, in terms
of circuit complexity, in AC0)
combined complexity: PSpace -complete
Complexity of conjunctive queries
data complexity: in LogSpace
combined complexity: NP-complete
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (9/199)

===== PAGE 15 =====

Information integration: Logical formalization
Syntax and semantics of an information integration system Formalization of information integration
Complexity of relational calculus
We consider the complexity of the recognition problem , i.e., checking
whether a tuple of constants is in the answer to a query:
measured wrt the size of the database ;data complexity
measured wrt the size of the query and the database ;
combined complexity
Complexity of relational calculus
data complexity: polynomial, actually in LogSpace (or, in terms
of circuit complexity, in AC0)
combined complexity: PSpace -complete
Complexity of conjunctive queries
data complexity: in LogSpace
combined complexity: NP-complete
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (9/199)

===== PAGE 16 =====

Information integration: Logical formalization
Queries to an information integration system Formalization of information integration
Outline of Part 1
1Information integration: Logical formalization
Syntax and semantics of an information integration system
Queries to an information integration system
Formalizing the mapping
Formalizing GAV information integration systems
Formalizing LAV information integration systems
Query answering in the various contexts
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (10/199)

===== PAGE 17 =====

Information integration: Logical formalization
Queries to an information integration system Formalization of information integration
Queries to a information integration system I
The domain ∆is fixed, and we do not distinguish an element of ∆
from the constant denoting it ;standard names
Queries to Iare relational calculus queries over the alphabet AGof
the global schema
When “evaluating” qoverI, we have to consider that for a given
source database C, there may be many global databases Bin
semC(I)
We consider those answers to qthat hold for allglobal databases in
semC(I)
;certain answers
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (11/199)

===== PAGE 18 =====

Information integration: Logical formalization
Queries to an information integration system Formalization of information integration
Semantics of queries to I
Definition
Given q,I, andC, the set of certain answers to qwrtIandCis
cert(q,I,C) =\
{qB| B ∈ semC(I)}
Query answering in information integration means to compute the
certain answers, i.e., it corresponds to logical implication
Complexity is measured mainly wrt the size of the source db C,
i.e., we consider data complexity
When we want to look at query answering as a decision problem,
we consider the problem of deciding whether a given tuple ⃗ cis a
certain answer to qwrtIandC, i.e., whether ⃗ c∈cert(q,I,C)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (12/199)

===== PAGE 19 =====

Information integration: Logical formalization
Queries to an information integration system Formalization of information integration
Databases with incomplete information, or knowledge bases
Traditional database: one model of a first-order theory.
Query answering means evaluating a formula in the model
Database with incomplete information, or knowledge base: set of
models (specified, for example, as a restricted first-order theory).
Query answering means computing the tuples that satisfy the query
inallthe models in the set
There is a strong connection between query answering in information
integration and query answering in databases with incomplete
information under constraints (or, query answering in knowledge bases)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (13/199)

===== PAGE 20 =====

Information integration: Logical formalization
Queries to an information integration system Formalization of information integration
Databases with incomplete information, or knowledge bases
Traditional database: one model of a first-order theory.
Query answering means evaluating a formula in the model
Database with incomplete information, or knowledge base: set of
models (specified, for example, as a restricted first-order theory).
Query answering means computing the tuples that satisfy the query
inallthe models in the set
There is a strong connection between query answering in information
integration and query answering in databases with incomplete
information under constraints (or, query answering in knowledge bases)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (13/199)

===== PAGE 21 =====

Information integration: Logical formalization
Queries to an information integration system Formalization of information integration
Query answering with incomplete information
[Reiter ’84]: relational setting, databases with incomplete
information modeled as a first order theory
[Vardi ’86]: relational setting, complexity of reasoning in closed
world databases with unknown values
Several approaches both from the DB and the KR community
[van der Meyden ’98]: survey on logical approaches to incomplete
information in databases
[Libkin ’10]: work on XML and incomplete information
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (14/199)

===== PAGE 22 =====

Information integration: Logical formalization
Formalizing the mapping Formalization of information integration
Outline of Part 1
1Information integration: Logical formalization
Syntax and semantics of an information integration system
Queries to an information integration system
Formalizing the mapping
Formalizing GAV information integration systems
Formalizing LAV information integration systems
Query answering in the various contexts
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (15/199)

===== PAGE 23 =====

Information integration: Logical formalization
Formalizing the mapping Formalization of information integration
The mapping
We only consider sound mappings, i.e., mapping assertions stating that
the presence of certain data in the sources implies the presence of
certain data in the virtual global database.
How is the mapping Mbetween SandGspecified?
Are the sources defined in terms of the global schema?
Approach called source-centric , orlocal-as-view , orLAV
Is the global schema defined in terms of the sources?
Approach called global-schema-centric , orglobal-as-view , or
GAV
A mixed approach?
Approach called GLAV
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (16/199)

===== PAGE 24 =====

Information integration: Logical formalization
Formalizing the mapping Formalization of information integration
GAV vs. LAV – Example
Global schema :
movie (Title,Year,Director )
european (Director )
review (Title,Critique )
Source 1 :
r1(Title,Year,Director )since 1960, european directors
Source 2 :
r2(Title,Critique )since 1990
Query : Title and critique of movies in 1998
{(t, r)| ∃d.movie (t,1998, d)∧review (t, r)},abbreviated
{(t, r)|movie (t,1998, d),review (t, r)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (17/199)

===== PAGE 25 =====

Information integration: Logical formalization
Formalizing GAV information integration systems Formalization of information integration
Outline of Part 1
1Information integration: Logical formalization
Syntax and semantics of an information integration system
Queries to an information integration system
Formalizing the mapping
Formalizing GAV information integration systems
Formalizing LAV information integration systems
Query answering in the various contexts
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (18/199)

===== PAGE 26 =====

Information integration: Logical formalization
Formalizing GAV information integration systems Formalization of information integration
Formalization of GAV
In GAV (with sound sources), the mapping Mis a set of assertions:
ϕS;g
one for each element ginAG, with ϕSa query over Sof the arity of g
Given a source db C, a db BforGsatisfies MwrtCif for each g∈ G:
ϕC
S⊆gB
In other words, the assertion means ∀⃗ x.ϕS(⃗ x)→g(⃗ x)
Given a source database C,Mprovides direct information about
which data in Csatisfy the elements of the global schema
Elements in the global schema Gcan be considered as views over the
sources. This is why this approach is called “global as view”
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (19/199)

===== PAGE 27 =====

Information integration: Logical formalization
Formalizing GAV information integration systems Formalization of information integration
GAV – Example
Global schema : movie (Title,Year,Director )
european (Director )
review (Title,Critique )
GAV: to each relation in the global schema, Massociates a view over
the sources:
{(t, y, d )|r1(t, y, d )};movie (t, y, d )
{(d)|r1(t, y, d )};european (d)
{(t, r)|r2(t, r)};review (t, r)
Logical formalization:
∀t, y, d .r1(t, y, d )→movie (t, y, d )
∀d.(∃t, y.r1(t, y, d ))→european (d)
∀t, r.r2(t, r)→review (t, r)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (20/199)

===== PAGE 28 =====

Information integration: Logical formalization
Formalizing GAV information integration systems Formalization of information integration
GAV – Examples of global databases
Cr1
AllAboutMyMother 1999 Almodovarr2
AllAboutMyMother 5∗
Joker 4∗
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (21/199)

===== PAGE 29 =====

Information integration: Logical formalization
Formalizing GAV information integration systems Formalization of information integration
GAV – Examples of global databases
Cr1
AllAboutMyMother 1999 Almodovarr2
AllAboutMyMother 5∗
Joker 4∗AAAAA K
 *
 B1movie
Title Year Director
AllAboutMyMother 1999 Almodovar
Oppenheimer 2023 Nolaneuropean
Director
Almodovarreview
Title Critique
AllAboutMyMother 5∗
Joker 4∗
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (21/199)

===== PAGE 30 =====

Information integration: Logical formalization
Formalizing GAV information integration systems Formalization of information integration
GAV – Examples of global databases
Cr1
AllAboutMyMother 1999 Almodovarr2
AllAboutMyMother 5∗
Joker 4∗AAAAA K
 *
 B1movie
Title Year Director
AllAboutMyMother 1999 Almodovar
Oppenheimer 2023 Nolaneuropean
Director
Almodovarreview
Title Critique
AllAboutMyMother 5∗
Joker 4∗



 HHHHHHHHHH jA
A
A
AA U
B2movie
Title Year Director
AllAboutMyMother 1999 Almodovareuropean
Director
Almodovar
Pasolinireview
Title Critique
AllAboutMyMother 5∗
Joker 4∗
TheGreatGatsby 5∗
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (21/199)

===== PAGE 31 =====

Information integration: Logical formalization
Formalizing GAV information integration systems Formalization of information integration
GAV – Example of query processing
The query
{(t, r)|movie (t,1998, d),review (t, r)}
is processed by expanding each atom according to its associated
definition in M, so as to come up with a query over the source relations
In particular:
{(t, r)|movie (t,1998, d),review (t, r)}
↓ ↓
{(t, r)| r1(t,1998, d), r2(t, r)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (22/199)

===== PAGE 32 =====

Information integration: Logical formalization
Formalizing LAV information integration systems Formalization of information integration
Outline of Part 1
1Information integration: Logical formalization
Syntax and semantics of an information integration system
Queries to an information integration system
Formalizing the mapping
Formalizing GAV information integration systems
Formalizing LAV information integration systems
Query answering in the various contexts
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (23/199)

===== PAGE 33 =====

Information integration: Logical formalization
Formalizing LAV information integration systems Formalization of information integration
Formalization of LAV
In LAV (with sound sources), the mapping Mis a set of assertions:
s;ϕG
one for each source element sinAS, with ϕGa query over G
Given source db C, a db BforGsatisfies MwrtCif for each s∈ S:
sC⊆ϕB
G
In other words, the assertion means ∀⃗ x.s(⃗ x)→ϕG(⃗ x)
The mapping Mand the source database Cdonotprovide direct
information about which data satisfy the global schema
Sources, i.e., elements in S, can be considered as views over the global
schema. This is why this approach is called “local-as-views” .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (24/199)

===== PAGE 34 =====

Information integration: Logical formalization
Formalizing LAV information integration systems Formalization of information integration
LAV – Example
Global schema : movie (Title,Year,Director )
european (Director )
review (Title,Critique )
LAV: to each source relation, Massociates a view over the global
schema:
r1(t, y, d );{(t, y, d )|movie (t, y, d ),european (d), y≥1960}
r2(t, r);{(t, r)|movie (t, y, d ),review (t, r), y≥1990}
The query {(t, r)|movie (t,1998, d),review (t, r)}is processed by
means of an inference mechanism that aims at re-expressing the atoms
of the global schema in terms of atoms at the sources.
In this case:
{(t, r)|r2(t, r),r1(t,1998, d)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (25/199)

===== PAGE 35 =====

Information integration: Logical formalization
Formalizing LAV information integration systems Formalization of information integration
GAV and LAV – Comparison
GAV : (e.g., Carnot, SIMS, Tsimmis, IBIS, Momis, DisAtDis, . . . )
Quality depends on how well we have compiled the sources into the
global schema through the mapping
Whenever a source changes or a new one is added, the mapping
needs to be reconsidered
Query processing can be based on some sort of unfolding (query
answering looks easier – without constraints)
LAV: (e.g., Information Manifold, DWQ, Picsel)
Quality depends on how well we have characterized the sources
High modularity and extensibility (if the global schema is well
designed, when a source changes, only its mapping is affected)
Query processing needs reasoning (query answering complex)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (26/199)

===== PAGE 36 =====

Information integration: Logical formalization
Formalizing LAV information integration systems Formalization of information integration
Beyond GAV and LAV: GLAV
In GLAV (with sound sources), the mapping Mis a set of assertions:
ϕS;ϕG
withϕSa query over S, and ϕGa query over Gof the same arity as ϕS
Given source db C, a db BforGsatisfies MwrtCif for each ϕS;ϕG
inM:
ϕC
S⊆ϕB
G
In other words, the assertion means ∀⃗ x.ϕS(⃗ x)→ϕG(⃗ x)
As for LAV, the mapping Mdoes notprovide direct information about
which data satisfy the global schema, and, therefore, to answer a query
qoverG, we have to infer how to use Min order to access the source
database C
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (27/199)

===== PAGE 37 =====

Information integration: Logical formalization
Formalizing LAV information integration systems Formalization of information integration
GLAV – Example
Global schema : work (Person ,Project ),area(Project ,Field )
Source 1 : hasjob (Person ,Field )
Source 2 : teaches (Professor ,Course ), in (Course ,Field )
Source 3 : get (Researcher ,Grant ), for (Grant ,Project )
GLAV mapping :
{(r, f)|hasjob (r, f)} ;{(r, f)|work(r, p),area(p, f)}
{(r, f)|teaches (r, c),in(c, f)};{(r, f)|work(r, p),area(p, f)}
{(r, p)|get(r, g),for(g, p)};{(r, f)|work(r, p)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (28/199)

===== PAGE 38 =====

Information integration: Logical formalization
Query answering in the various contexts Formalization of information integration
Outline of Part 1
1Information integration: Logical formalization
Syntax and semantics of an information integration system
Queries to an information integration system
Formalizing the mapping
Formalizing GAV information integration systems
Formalizing LAV information integration systems
Query answering in the various contexts
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (29/199)

===== PAGE 39 =====

Information integration: Logical formalization
Query answering in the various contexts Formalization of information integration
Query answering in different approaches
The problem of query answering comes in different forms, depending on
several parameters:
Global schema
without constraints (i.e., empty theory)
with constraints
Mapping
GAV
LAV (orGLAV )
Query languages
for user queries
for the queries in the mapping
If not otherwise stated, we will assume that both the user queries and
the queries in the mappings are conjunctive queries
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (30/199)

===== PAGE 40 =====

Information integration: Logical formalization
Query answering in the various contexts Formalization of information integration
Incompleteness and inconsistency
Incompleteness: the cardinality of semC(I)is greater than 1
Inconsistency: the cardinality of semC(I)is 0
Query answering heavily depends upon whether
incompleteness/inconsistency shows up
Constraints in GType of mapping Incompleteness Inconsistency
no GAV yes/ no no
no (G)LAV yes no
yes GAV yes yes
yes (G)LAV yes yes
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (31/199)

===== PAGE 41 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Part 2: Query answering and data exchange without constraints
Problems studied and corresponding techniques
Constraints in GType of mapping Data integration Data exchange
no GAV yes no
no (G)LAV yes no
yes GAV yes yes
yes (G)LAV yes yes
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (32/199)

===== PAGE 42 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
Retrieved global database
Query answering via unfolding
More expressive queries?
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (33/199)

===== PAGE 43 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Part 2: Query answering and data exchange without constraints
GAV data integration systems without constraints
Constraints in GType of mapping Incompleteness Inconsistency
no GAV yes/ no no
no (G)LAV yes no
yes GAV yes yes
yes (G)LAV yes yes
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (34/199)

===== PAGE 44 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Retrieved global database Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
Retrieved global database
Query answering via unfolding
More expressive queries?
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (35/199)

===== PAGE 45 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Retrieved global database Part 2: Query answering and data exchange without constraints
GAV – Retrieved global database
Definition
Given a GAV information integration system I=⟨G,S,M⟩and a
source database CforS, we call retrieved global database (forIwrt
C), denoted M(C), the global database obtained by “applying” the
queries in the mapping, and “transferring” to the elements of Gthe
corresponding tuples retrieved from C
Note that, since mappings are of type GAV, the tuples to be
“transferred” to the global schema are definite (they do not contain
existentially quantified elements)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (36/199)

===== PAGE 46 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Retrieved global database Part 2: Query answering and data exchange without constraints
GAV – Example
Consider I=⟨G,S,M⟩, with
Global schema G: student (Code ,Name ,City)
university (Code ,Name )
enrolled (Scode ,Ucode )
Source schema S: relations s 1(Scode ,Sname ,City,Age),
s2(Ucode ,Uname ),s3(Scode ,Ucode )
Mapping M:
{(c, n,ci)|s1(c, n,ci, a)};student (c, n,ci)
{(c, n)|s2(c, n)};university (c, n)
{(s, u)|s3(s, u)};enrolled (s, u)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (37/199)

===== PAGE 47 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Retrieved global database Part 2: Query answering and data exchange without constraints
GAV – Example of retrieved global database
sC
1
12 anne florence 21
15 bill oslo 24sC
2
AF bocconi
BN uclasC
3
12 AF
16 BN *
PPPPPPPPPPPPP i
 university
Code Name
AF bocconi
BN uclastudent
Code Name City
12 anne florence
15 bill osloenrolled
Scode Ucode
12 AF
16 BN
Example of source database Cand corresponding retrieved global
database M(C)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (38/199)

===== PAGE 48 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Retrieved global database Part 2: Query answering and data exchange without constraints
GAV – Minimal model
GAV mapping assertions ϕS;ghave the logical form:
∀⃗ x.ϕS(⃗ x)→g(⃗ x)
where ϕSis a conjunctive query over the source relations, and gis an
element of G.
In general, given a source database C, there are several databases legal
wrtGthat satisfy MwrtC. However, it is easy to prove the following
Theorem
IfGhas no axiom, M(C)is the intersection of all such databases, and
therefore, is the only “minimal” model ofI.
Theorem
Ifqis a positive query, then ⃗t∈cert(q,I,C)iff⃗t∈qM(C)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (39/199)

===== PAGE 49 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Query answering via unfolding Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
Retrieved global database
Query answering via unfolding
More expressive queries?
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (40/199)

===== PAGE 50 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Query answering via unfolding Part 2: Query answering and data exchange without constraints
GAV – Query answering via unfolding
Theunfolding wrt Mof a query qoverG, denoted unfM(q), is the
query over Sobtained from qby substituting every symbol ginqwith
the query ϕSthatMassociates to g.
Theorem
Evaluating qoverM(C)is equivalent to evaluating unfM(q)overC,
i.e.,⃗t∈qM(C)iff⃗t∈unfM(q)C
Theorem
Ifqis a conjunctive query, then ⃗t∈cert(q,I,C)iff⃗t∈qM(C).
Hence, ⃗t∈cert(q,I,C)iff⃗t∈qM(C)iff⃗t∈unfM(q)C
;Unfolding suffices for query answering in GAV without constraints
Data complexity of query answering is polynomial , actually
LogSpace : the query unfM(q)is first-order (in fact conjunctive)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (41/199)

===== PAGE 51 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Query answering via unfolding Part 2: Query answering and data exchange without constraints
GAV – Example of unfolding
sC
2
AF bocconi
BN uclasC
1
12 anne florence 21
15 bill oslo 24student
Code Name City
12 anne florence
15 bill oslouniversity
Code Name
AF bocconi
BN ucla
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (42/199)

===== PAGE 52 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Query answering via unfolding Part 2: Query answering and data exchange without constraints
GAV – Example of unfolding
{x|student (15, x, y)}
sC
2
AF bocconi
BN uclasC
1
12 anne florence 21
15 bill oslo 24student
Code Name City
12 anne florence
15 bill oslouniversity
Code Name
AF bocconi
BN ucla
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (42/199)

===== PAGE 53 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Query answering via unfolding Part 2: Query answering and data exchange without constraints
GAV – Example of unfolding
{x|s1(15, x, y, z )}unfolding{x|student (15, x, y)}
sC
2
AF bocconi
BN uclasC
1
12 anne florence 21
15 bill oslo 24student
Code Name City
12 anne florence
15 bill oslouniversity
Code Name
AF bocconi
BN ucla
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (42/199)

===== PAGE 54 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
Retrieved global database
Query answering via unfolding
More expressive queries?
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (43/199)

===== PAGE 55 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
GAV – More expressive queries?
Do the results extend to the case of more expressive queries?
With more expressive queries in the mapping?
Same results hold if we use the relational calculus as query
language for the source queries in the mapping
With more expressive user queries?
Same results hold if we use union of conjunctive queries with
inequalities as user queries [van der Meyden TCS’93]
With Datalog queries as user queries, computing certain answers
can be done in polynomial time
Ifrelational calculus is used as user query language, then
computing certain answers becomes undecidable
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (44/199)

===== PAGE 56 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
GAV – More expressive queries?
Do the results extend to the case of more expressive queries?
With more expressive queries in the mapping?
Same results hold if we use the relational calculus as query
language for the source queries in the mapping
With more expressive user queries?
Same results hold if we use union of conjunctive queries with
inequalities as user queries [van der Meyden TCS’93]
With Datalog queries as user queries, computing certain answers
can be done in polynomial time
Ifrelational calculus is used as user query language, then
computing certain answers becomes undecidable
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (44/199)

===== PAGE 57 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
GAV – More expressive queries?
Do the results extend to the case of more expressive queries?
With more expressive queries in the mapping?
Same results hold if we use the relational calculus as query
language for the source queries in the mapping
With more expressive user queries?
Same results hold if we use union of conjunctive queries with
inequalities as user queries [van der Meyden TCS’93]
With Datalog queries as user queries, computing certain answers
can be done in polynomial time
Ifrelational calculus is used as user query language, then
computing certain answers becomes undecidable
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (44/199)

===== PAGE 58 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
Data exchange setting
Homomorphisms
Solutions and universal solutions
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (45/199)

===== PAGE 59 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Data exchange setting Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
Data exchange setting
Homomorphisms
Solutions and universal solutions
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (46/199)

===== PAGE 60 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Data exchange setting Part 2: Query answering and data exchange without constraints
Data exchange setting
Data exchange aims at transferring data from a source database (let S
be the source schema) to a target database (let Tbe the target
schema), according to a set Σof so-called source-to-target
dependencies, which are actually GLAV mappings specifying the
relationship between SandT.
Definition
Adata exchange setting is a tuple M=⟨S,T,Σ⟩, where Σis a set of
GLAV mapping assertions written as:
ϕS→ϕG
withϕSa conjunctive query over S, and ϕGa conjunctive query over T
of the same arity as ϕS
GLAV mappings of the above form are also called tuple-generating
dependencies.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (47/199)

===== PAGE 61 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Data exchange setting Part 2: Query answering and data exchange without constraints
Target databases
To deal with data exchange coherently with the literature, we introduce
the notion of target database, as an extension of the notion of global
database in our framework.
Let Var denote an alphabet of symbols disjoint from AG, from ASand
from the alphabet of constants. Intuitively Var is a set of symbols that
we can use as variables in our target databases.
Definition
A target database for a data exchange setting M=⟨S,T,Σ⟩is a finite
database for the target schema Tdefined over the extended domain
∆∪Var.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (48/199)

===== PAGE 62 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Data exchange setting Part 2: Query answering and data exchange without constraints
Instances and solutions
Definitions, concepts, results and examples are taken from
[Fagin & al. TCS’05] and from [Kolaitis DASI’06] (slides of the DASI
School)
Definition
IfIis a finite source instance (i.e., a database for S) for
M=⟨S,T,Σ⟩, asolution for IandMis a finite target instance (i.e.,
a database for T)Jsuch that ⟨I, J⟩satisfies Σ(written ⟨I, J⟩ |= Σ).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (49/199)

===== PAGE 63 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Data exchange setting Part 2: Query answering and data exchange without constraints
Comparison between data integration and data exchange
Data integration system I=⟨G,S,M⟩
Data exchange setting M=⟨S,T,Σ⟩
I=⟨G,S,M⟩ M=⟨S,T,Σ⟩
S S
G T
M Σ
finite source database C finite source instance I
global database target instance is finite
withno variable andmay contain variables
global database Bsatisfying
GandMwrtC: solution JforI:
B ∈semC(I) Jsuch that ⟨I, J⟩ |= Σ
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (50/199)

===== PAGE 64 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Homomorphisms Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
Data exchange setting
Homomorphisms
Solutions and universal solutions
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (51/199)

===== PAGE 65 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Homomorphisms Part 2: Query answering and data exchange without constraints
Homomorphisms
LetD1andD2be two databases with values in ∆∪Var
Definition
Ahomomorphism h:D1→ D 2is a mapping from ( ∆∪Var(D1)) to
(∆∪Var(D2)) such that
1h(c) =c, for every constant c∈∆
2each variable is mapped to a constant or a variable by h
3for every fact ri(⃗t)ofD1, we have that ri(h(⃗t))is a fact in D2
Definition
D1ishomomorphically equivalent toD2if there is a homomorphism
h:D1→ D 2and a homomorphism h′:D2→ D 1
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (52/199)

===== PAGE 66 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
Data exchange setting
Homomorphisms
Solutions and universal solutions
4Query answering in (G)LAV without constraints
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (53/199)

===== PAGE 67 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Multiple solutions
Given a source instance, multiple solutions may exist.
Example
S: E(A,B)
T: H(A,B)
Σ: E(x,y) →(H(x,z) ∧H(z,y))
Source instance I:{E(a,b) }
Infinitely many solutions exist (a,b constants, X,Y variables):
J1={H(a,b), H(b,b) }
J2={H(a,a), H(a,b) }
J3={H(a,X), H(X,b) }
J4={H(a,X), H(X,b), H(a,Y), H(Y,b) }
J5={H(a,X), H(X,b), H(Y,Y) }
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (54/199)

===== PAGE 68 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Multiple solutions
For a given source instance, there may be multiple target instances
satisfying the specifications of the schema mapping. Thus,
When more than one solution exist, which solutions are better than
others?
How do we compute a best solution?
In other words, what is a good materialization of target data, i.e.,
the right semantics of data exchange?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (55/199)

===== PAGE 69 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Universal solutions
LetM=⟨S,T,Σ⟩be a data exchange setting, and Ia source instance
Definition
Auniversal solution forIandMis a solution JforIandMsuch
that, for every solution J′forIandM, there exists a homomorphism
h:J→J′(see [Fagin & al. TCS’05])
In other words, a universal solution is a “most general” solution for the
data exchange setting relative to the given source instance.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (56/199)

===== PAGE 70 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Universal solution: example
Example
S: E(A,B)
T: H(A,B)
Σ: E(x,y) →(H(x,z) ∧H(z,y))
Source instance I:{E(a,b) }
Solutions (a,b constants, X,Y variables):
J1={H(a,b), H(b,b) }–notuniversal
J2={H(a,a), H(a,b) }–notuniversal
J3={H(a,X), H(X,b) }– universal
J4={H(a,X), H(X,b), H(a,Y), H(Y,b) }– universal
J5={H(a,X), H(X,b), H(Y,Y) }–notuniversal
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (57/199)

===== PAGE 71 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Properties of universal solutions
Universal solutions are analogous to most general unifiers in logic
programming.
Uniqueness up to homomorphic equivalence: If J and J’ are
universal for I, then they are homomorphically equivalent.
Representation of the entire space of solutions: Assume that J is
universal for I, and J’ is universal for I’. Then the following are
equivalent:
I and I’ have the same space of solutions.
J and J’ are homomorphically equivalent.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (58/199)

===== PAGE 72 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
The naive chase algorithm
Input :M=⟨S,T,Σ⟩, source instance I
Output : target instance J
J← ∅;
for all (∀⃗ xϕ(⃗ x)→ ∃y ψ(⃗ x, ⃗ y))∈Σdo
for all tuples of constants ⃗ asuch that ⃗ a∈ϕIdo
for each yi∈⃗ y, pick a fresh variable Xiforyi;
add the facts in ψ(⃗ a,⃗X)toJ
end for
end for ;
return J
The algorithm builds a target instance J= Σ( I)that satisfies each
mapping in Σby introducing new facts in Jas dictated by the
source-side of the mapping, and by introducing new values (variables) in
Jas witnesses for the existential quantifiers in the target-side.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (59/199)

===== PAGE 73 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Computing universal solutions
Theorem
LetM=⟨S,T,Σ⟩be a data exchange setting, and Ia source instance.
Then
there is a solution for IandM
a universal solution can be constructed in polynomial time with
respect to the size of I(data complexity)
The proof exploits the fact that the naive chase algorithm builds a
universal solution.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (60/199)

===== PAGE 74 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Example of computation of universal solutions
Collapsing paths of length 2 to edges
Example
Σ:E(x, z)∧E(z, y)→F(x, y)(GAV mapping)
I1={E(1,3), E(2,4), E(3,4)}
J1={F(1,4)}– universal solution for I1
I2={E(1,3), E(2,4), E(3,4), E(4,3)}
J2={F(1,4), F(2,3), F(3,3)}– universal solution for I2
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (61/199)

===== PAGE 75 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Example of computation of universal solutions
Expanding edges to paths of length 2
Example
Σ:E(x, y)→F(x, z)∧F(z, y)(LAV mapping)
I1={E(1,2)}
J1={F(1, X), F(X,2)}– universal solution for I1
I2={E(1,2), E(3,4)}
J2={F(1, X), F(X,2), F(3, Y), F(Y,4)}– universal solution for
I2
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (62/199)

===== PAGE 76 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Computing universal solutions
LetM=⟨S,T,Σ⟩be a data exchange setting, and Ia source instance
Theorem
IfΣis a set of GAV mappings, then Σ(I)is the minimal universal
solution forIandM.
Theorem
IfΣis a set of GLAV mappings, then Σ(I)is auniversal solution forI
andM.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (63/199)

===== PAGE 77 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
Computing certain answers through universal solutions
IfBis a database with variables, and qis query, then we denote by qB↓
the set of tuples obtained by evaluating QoverBand by ignoring the
tuples containing variables.
Theorem
Ifqis a conjunctive query, then ⃗t∈cert(q,Σ, I)iff⃗t∈qΣ(I)↓
Complexity of computing the certain answers to qwith respect to
MandIis polynomial
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (64/199)

===== PAGE 78 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
(G)LAV – Conjunctive user queries with inequalities
Consider I=⟨G,S,M⟩, and source db C(see [Fagin & al. ICDT’03]):
G:g(x, y) S:s(x, y)
M:s(x, y);{(x, y)|g(x, z)∧g(z, y)}
C:{s(a,a)}
B1={g(a,a)}is a solution
IfBis a universal solution, then both g(a, x)andg(x,a)are in B,
withx̸=a(otherwise g(a,a)would be true in every solution)
Let q={()|g(x, y)∧x̸=y}
qB1=false , hence cert(q,I,C) =false
ButqB=true for every universal solution BforIrelative to C
Hence, the notion of universal solution is not the right tool
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (65/199)

===== PAGE 79 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
(G)LAV – Conjunctive user queries with inequalities
Consider I=⟨G,S,M⟩, and source db C(see [Fagin & al. ICDT’03]):
G:g(x, y) S:s(x, y)
M:s(x, y);{(x, y)|g(x, z)∧g(z, y)}
C:{s(a,a)}
B1={g(a,a)}is a solution
IfBis a universal solution, then both g(a, x)andg(x,a)are in B,
withx̸=a(otherwise g(a,a)would be true in every solution)
Let q={()|g(x, y)∧x̸=y}
qB1=false , hence cert(q,I,C) =false
ButqB=true for every universal solution BforIrelative to C
Hence, the notion of universal solution is not the right tool
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (65/199)

===== PAGE 80 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
(G)LAV – Conjunctive user queries with inequalities
coNP algorithm: guess equalities on variables in Σ(I)
coNP-hard already for a conjunctive user query with two
inequalities (and mappings LAV) [Fagin & al. ICDT’03]
Theorem
For conjunctive user queries with inequalities, (G)LAV query answering
iscoNP-complete in data complexity
Note: inequalities in the view definitions (i.e., mapping queries) do not
affect expressive power and complexity (in fact, they can be removed)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (66/199)

===== PAGE 81 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Solutions and universal solutions Part 2: Query answering and data exchange without constraints
(G)LAV – Conjunctive user queries with inequalities
coNP algorithm: guess equalities on variables in Σ(I)
coNP-hard already for a conjunctive user query with two
inequalities (and mappings LAV) [Fagin & al. ICDT’03]
Theorem
For conjunctive user queries with inequalities, (G)LAV query answering
iscoNP-complete in data complexity
Note: inequalities in the view definitions (i.e., mapping queries) do not
affect expressive power and complexity (in fact, they can be removed)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (66/199)

===== PAGE 82 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
(G)LAV and incompleteness
Approaches to query answering in (G)LAV
(G)LAV: Direct methods (aka view-based query answering)
(G)LAV: Query answering by (view-based) query rewriting
(G)LAV: Query answering vs query containment
More expressive queries?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (67/199)

===== PAGE 83 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Part 2: Query answering and data exchange without constraints
(G)LAV data integration systems without constraints
Constraints in GType of mapping Incompleteness Inconsistency
no GAV yes/ no no
no (G)LAV yes no
yes GAV yes yes
yes (G)LAV yes yes
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (68/199)

===== PAGE 84 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV and incompleteness Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
(G)LAV and incompleteness
Approaches to query answering in (G)LAV
(G)LAV: Direct methods (aka view-based query answering)
(G)LAV: Query answering by (view-based) query rewriting
(G)LAV: Query answering vs query containment
More expressive queries?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (69/199)

===== PAGE 85 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV and incompleteness Part 2: Query answering and data exchange without constraints
(G)LAV – Example
Consider I=⟨G,S,M⟩, with
Global schema G: student (Code ,Name ,City)
enrolled (Scode ,Ucode )
Source schema S: relation s 1(Scode ,Sname ,City,Age)
Mapping M:
{(c, n,ci)|s1(c, n,ci, a)};{(c, n,ci)|student (c, n,ci),
enrolled (c, u)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (70/199)

===== PAGE 86 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV and incompleteness Part 2: Query answering and data exchange without constraints
(G)LAV – Example
{(c, n,ci)|s1(c, n,ci, a)};{(c, n,ci)|student (c, n,ci),
enrolled (c, u)}
sC
1
12 anne florence 21
15 bill oslo 246
 :student
Code Name City
12 anne florence
15 bill osloenrolled
Scode Ucode
12 x
15 y
A source db Cand a corresponding possible retrieved global db M(C)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (71/199)

===== PAGE 87 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV and incompleteness Part 2: Query answering and data exchange without constraints
(G)LAV – Example
{(c, n,ci)|s1(c, n,ci, a)};{(c, n,ci)|student (c, n,ci),
enrolled (c, u)}
sC
1
12 anne florence 21
15 bill oslo 246
 :student
Code Name City
12 anne florence
15 bill osloenrolled
Scode Ucode
12 x
15 x
A source db Cand another possible retrieved global db M(C)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (71/199)

===== PAGE 88 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV and incompleteness Part 2: Query answering and data exchange without constraints
(G)LAV – Incompleteness
(G)LAV mapping assertions ϕS;ϕGhave the logical form:
∀⃗ x.ϕS(⃗ x)→ ∃⃗ y.ϕG(⃗ x, ⃗ y)
where ϕSandϕGare conjunctions of atoms
Given a source database C, in general there are several global databases
that are legal wrt Gand satisfy a set of (G)LAV assertions MwrtC
;Incompleteness comes from the mapping
This holds even for the case of very simple queries ϕG:
s1(x);{(x)| ∃y.g(x, y)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (72/199)

===== PAGE 89 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Approaches to query answering in (G)LAV Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
(G)LAV and incompleteness
Approaches to query answering in (G)LAV
(G)LAV: Direct methods (aka view-based query answering)
(G)LAV: Query answering by (view-based) query rewriting
(G)LAV: Query answering vs query containment
More expressive queries?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (73/199)

===== PAGE 90 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Approaches to query answering in (G)LAV Part 2: Query answering and data exchange without constraints
(G)LAV – Approaches to query answering
Direct methods (aka view-based query answering):
Try to answer directly the query by means of an algorithm that
takes as input the user query q, the specification of I, and the
source database C
By (view-based) query rewriting:
1Taking into account I, reformulate the user query qas a new query
(called a rewriting ofq) over the source relations
2Evaluate the rewriting over the source database C
Exploit connection with query containment
Note: In (G)LAV data integration the views are the sources
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (74/199)

===== PAGE 91 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Approaches to query answering in (G)LAV Part 2: Query answering and data exchange without constraints
(G)LAV – Approaches to query answering
Direct methods (aka view-based query answering):
Try to answer directly the query by means of an algorithm that
takes as input the user query q, the specification of I, and the
source database C
By (view-based) query rewriting:
1Taking into account I, reformulate the user query qas a new query
(called a rewriting ofq) over the source relations
2Evaluate the rewriting over the source database C
Exploit connection with query containment
Note: In (G)LAV data integration the views are the sources
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (74/199)

===== PAGE 92 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Approaches to query answering in (G)LAV Part 2: Query answering and data exchange without constraints
(G)LAV – Approaches to query answering
Direct methods (aka view-based query answering):
Try to answer directly the query by means of an algorithm that
takes as input the user query q, the specification of I, and the
source database C
By (view-based) query rewriting:
1Taking into account I, reformulate the user query qas a new query
(called a rewriting ofq) over the source relations
2Evaluate the rewriting over the source database C
Exploit connection with query containment
Note: In (G)LAV data integration the views are the sources
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (74/199)

===== PAGE 93 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
Approaches to query answering in (G)LAV Part 2: Query answering and data exchange without constraints
(G)LAV – Approaches to query answering
Direct methods (aka view-based query answering):
Try to answer directly the query by means of an algorithm that
takes as input the user query q, the specification of I, and the
source database C
By (view-based) query rewriting:
1Taking into account I, reformulate the user query qas a new query
(called a rewriting ofq) over the source relations
2Evaluate the rewriting over the source database C
Exploit connection with query containment
Note: In (G)LAV data integration the views are the sources
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (74/199)

===== PAGE 94 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Direct methods (aka view-based query answering) Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
(G)LAV and incompleteness
Approaches to query answering in (G)LAV
(G)LAV: Direct methods (aka view-based query answering)
(G)LAV: Query answering by (view-based) query rewriting
(G)LAV: Query answering vs query containment
More expressive queries?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (75/199)

===== PAGE 95 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Direct methods (aka view-based query answering) Part 2: Query answering and data exchange without constraints
(G)LAV – Direct methods for query answering
Through the notion of universal solution (see the part on data
exchange)
Through logic programs
All methods are “equivalent” from the point of view of computational
complexity
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (76/199)

===== PAGE 96 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Direct methods (aka view-based query answering) Part 2: Query answering and data exchange without constraints
(G)LAV – Query answering through logic program
From [Duschka & Genesereth PODS’97]:
r1(t);{(t)|movie (t, y, d )∧european (d)}
r2(t, v);{(t, v)|movie (t, y, d )∧review (t, v)}
∀t.r1(t)→ ∃y, d.movie (t, y, d )∧european (d)
∀t, v.r2(t, v)→ ∃y, d.movie (t, y, d )∧review (t, v)
movie (t, f1(t), f2(t))← r1(t)
european (f2(t))← r1(t)
movie (t, f4(t, v), f5(t, v))← r2(t, v)
review (t, v)← r2(t, v)
Answering a query means evaluating a goal wrt to this nonrecursive
logic program (which can be transformed into a union of CQs)
;Data complexity is polynomial (actually LogSpace )
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (77/199)

===== PAGE 97 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
(G)LAV and incompleteness
Approaches to query answering in (G)LAV
(G)LAV: Direct methods (aka view-based query answering)
(G)LAV: Query answering by (view-based) query rewriting
(G)LAV: Query answering vs query containment
More expressive queries?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (78/199)

===== PAGE 98 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Query answering based on query rewriting
Given data integration system I, and a user query q, compute a query
q1overAS, and then compute qC
1
Thus, query answering is divided in two steps:
1Reformulate the user query in terms of a new query over the
alphabet of AS, called source rewriting, or simply rewriting
expressed in a given query language
2Evaluate the rewriting over the source database C
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (79/199)

===== PAGE 99 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Query rewriting
(under OWA)
Query
(under CWA)evaluationrew(q,I)
ans(q,I,C)I
CReformulation q
The language of rew(q,I)ischosen a priori!
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (80/199)

===== PAGE 100 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
What is a rewriting?
Definition
A query q1over the alphabet ASis asound rewriting of qwith
respect to Iif for all source database Cand for all global database
B ∈semC(I), we have that qC
1⊆qB
From the above definition, it follows that a sound rewriting computes
only certain answers: indeed, if q1is a sound rewriting, then for all
source database C,
qC
1⊆\
{qB| B ∈ semC(I)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (81/199)

===== PAGE 101 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Perfect rewriting
What is the relationship between answering by rewriting and certain
answers? [Calvanese & al. ICDT’05]:
When does the (maximal) rewriting compute allcertain answers?
What do we gain or loose by focusing on a given class of queries?
Let’s try to consider the “ best possible ” rewriting
Define cert[q,I](·)to be the function that, with qandIfixed, given
source database C, computes the certain answers cert(q,I,C).
cert[q,I]can be seen as a query on the alphabet AS
cert[q,I]is a (sound) rewriting of qwrtI, i.e., it computes only
certain answers
No sound rewriting exists that is better than cert[q,I]
Hence, cert[q,I]is called the perfect rewriting ofqwrtI
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (82/199)

===== PAGE 102 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Perfect rewriting
What is the relationship between answering by rewriting and certain
answers? [Calvanese & al. ICDT’05]:
When does the (maximal) rewriting compute allcertain answers?
What do we gain or loose by focusing on a given class of queries?
Let’s try to consider the “ best possible ” rewriting
Define cert[q,I](·)to be the function that, with qandIfixed, given
source database C, computes the certain answers cert(q,I,C).
cert[q,I]can be seen as a query on the alphabet AS
cert[q,I]is a (sound) rewriting of qwrtI, i.e., it computes only
certain answers
No sound rewriting exists that is better than cert[q,I]
Hence, cert[q,I]is called the perfect rewriting ofqwrtI
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (82/199)

===== PAGE 103 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Perfect rewriting
What is the relationship between answering by rewriting and certain
answers? [Calvanese & al. ICDT’05]:
When does the (maximal) rewriting compute allcertain answers?
What do we gain or loose by focusing on a given class of queries?
Let’s try to consider the “ best possible ” rewriting
Define cert[q,I](·)to be the function that, with qandIfixed, given
source database C, computes the certain answers cert(q,I,C).
cert[q,I]can be seen as a query on the alphabet AS
cert[q,I]is a (sound) rewriting of qwrtI, i.e., it computes only
certain answers
No sound rewriting exists that is better than cert[q,I]
Hence, cert[q,I]is called the perfect rewriting ofqwrtI
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (82/199)

===== PAGE 104 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Query answering: reformulation + evaluation
(under OWA)
Query
(under CWA)evaluationcert[q,I]
cert(q,I,C)I
CPerfect
reformulationq
The query cert[q,I]could be expressed in an arbitrary query language
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (83/199)

===== PAGE 105 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
(G)LAV – More about rewriting
We are interested in rewritings rthat are:
sound , i.e., computes only tuples in cert(q,I,C)for every C(i.e.,
r⊆cert[q,I])
expressed in a given query language L
sound , and maximal for the class of queries expressible in L
perfect
A sound rewriting rofqwrtIismaximal for Lif for all r′∈ L,
r′⊆cert[q,I]implies r̸⊂r′
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (84/199)

===== PAGE 106 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
(G)LAV – More about rewriting
We are interested in rewritings rthat are:
sound , i.e., computes only tuples in cert(q,I,C)for every C(i.e.,
r⊆cert[q,I])
expressed in a given query language L
sound , and maximal for the class of queries expressible in L
perfect
A sound rewriting rofqwrtIismaximal for Lif for all r′∈ L,
r′⊆cert[q,I]implies r̸⊂r′
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (84/199)

===== PAGE 107 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
LAV – Example of maximal rewriting
G: nonstop (Airline ,Num ,From ,To)
S: flightsByUnited (Numm ,From ,To)
flightsFromSFO (Airline ,Num ,To)
M: flightsByUnited (Num ,From ,To);
nonstop (UA,Num ,From ,To)
flightsFromSFO (Airline ,Num ,To);
nonstop (Airline ,Num ,SFO,To)
q:{(airline ,num)|nonstop (airline ,num,LAX,PHX)}
Amaximal (wrt positive queries) rewriting ofqis:
{(UA,num)|flightsByUnited (num,LAX,PHX)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (85/199)

===== PAGE 108 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
LAV – Example of maximal rewriting
G: nonstop (Airline ,Num ,From ,To)
S: flightsByUnited (Numm ,From ,To)
flightsFromSFO (Airline ,Num ,To)
M: flightsByUnited (Num ,From ,To);
nonstop (UA,Num ,From ,To)
flightsFromSFO (Airline ,Num ,To);
nonstop (Airline ,Num ,SFO,To)
q:{(airline ,num)|nonstop (airline ,num,LAX,PHX)}
Amaximal (wrt positive queries) rewriting ofqis:
{(UA,num)|flightsByUnited (num,LAX,PHX)}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (85/199)

===== PAGE 109 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
Properties of the perfect rewriting
Can the perfect rewriting be expressed in a certain query language?
For a given class of queries, what is the relationship between a
maximal rewriting and the perfect rewriting?
From a semantical point of view
From a computational point of view
Which is the computational complexity of finding the perfect
rewriting, and how big is it?
Which is the computational complexity of evaluating the perfect
rewriting?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (86/199)

===== PAGE 110 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
LAV – Connection to rewriting
Given a LAV data integration system I=⟨G,S,M⟩, and a query q′
overS,exp(q′)is the query over Gthat is obtained by substituting
every atom with the view that Massociates to it.
Theorem
Letqbe a conjunctive query over G, and q′a conjunctive query over S.
q′is asound rewriting of qif and only if exp(q′)⊆q.
We may be interested in exact rewritings, i.e., rewritings q′that are
logically equivalent to the query, modulo M(i.e., for every source
database Cand every global database BinsemC(I),qB= (exp(q′))B).
However, exact rewritings may not exist.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (87/199)

===== PAGE 111 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
LAV – Connection to rewriting
Given a LAV data integration system I=⟨G,S,M⟩, and a query q′
overS,exp(q′)is the query over Gthat is obtained by substituting
every atom with the view that Massociates to it.
Theorem
Letqbe a conjunctive query over G, and q′a conjunctive query over S.
q′is asound rewriting of qif and only if exp(q′)⊆q.
We may be interested in exact rewritings, i.e., rewritings q′that are
logically equivalent to the query, modulo M(i.e., for every source
database Cand every global database BinsemC(I),qB= (exp(q′))B).
However, exact rewritings may not exist.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (87/199)

===== PAGE 112 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
LAV – Rewriting for conjunctive queries
Consider a LAV data integration system I=⟨G,S,M⟩, and a query q
overG. Let qand the queries in Mbe conjunctive queries.
Theorem
If the body of qhasnatoms, and q′is a maximal rewriting in the class
of conjunctive queries, then q′has at most natoms.
Sketch of the proof: Since q′is a rewriting of q, we have that
exp(q′)⊆q. Consider the homomorphism hfrom qtoexp(q′). Each
atom in qis mapped by hto at most one atom in exp(q′). If there are
more than natoms in q′, then the expansion of some atom in q′is
disjoint from the image of h, and then this atom can be removed from
q′while preserving containment (i.e., q′is not maximal).
This provides us with an algorithm for computing the set of maximal
conjunctive rewritings.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (88/199)

===== PAGE 113 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
LAV – The case of conjunctive queries
Letq′be the union of all maximal rewritings of qfor the class of
CQs
Theorem (Levy & al. PODS’95, Abiteboul & Duschka PODS’98)
q′isthemaximal rewriting for the class of unions of conjunctive
queries (UCQs)
q′is the perfect rewriting of qwrtI
q′is a PTIME query (actually, LogSpace )
q′is an exact rewriting (equivalent to qfor each database BofI),
if an exact rewriting exists
Does this “ideal situation” carry on to cases where qandMallow for
union?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (89/199)

===== PAGE 114 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
LAV – The case of conjunctive queries
Letq′be the union of all maximal rewritings of qfor the class of
CQs
Theorem (Levy & al. PODS’95, Abiteboul & Duschka PODS’98)
q′isthemaximal rewriting for the class of unions of conjunctive
queries (UCQs)
q′is the perfect rewriting of qwrtI
q′is a PTIME query (actually, LogSpace )
q′is an exact rewriting (equivalent to qfor each database BofI),
if an exact rewriting exists
Does this “ideal situation” carry on to cases where qandMallow for
union?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (89/199)

===== PAGE 115 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering by (view-based) query rewriting Part 2: Query answering and data exchange without constraints
(G)LAV – View-based query processing for UPQs
When queries over the global schema in the mapping contain union :
We will see that view-based query answering is coNP-complete in
data complexity [van der Meyden TCS’93]
hence, cert(q,I,C), with q,Ifixed, is a coNP-complete function
hence, the perfect rewriting cert[q,I]is a coNP-complete query ,
and therefore cannot be expressed as a union of conjunctive query
We do not have the ideal situation we had for conjunctive queries
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (90/199)

===== PAGE 116 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering vs query containment Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
(G)LAV and incompleteness
Approaches to query answering in (G)LAV
(G)LAV: Direct methods (aka view-based query answering)
(G)LAV: Query answering by (view-based) query rewriting
(G)LAV: Query answering vs query containment
More expressive queries?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (91/199)

===== PAGE 117 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering vs query containment Part 2: Query answering and data exchange without constraints
Connection between query answering and containment
Definition
Query containment (under constraints) is the problem of checking
whether qD
1is contained in qD
2for every database D(satisfying the
constraints), where q1,q2are queries of the same arity
Query answering can be rephrased in terms of query containment:
A source database Ccan be represented as a conjunction qCof
ground literals over AS(e.g., if ⃗ c∈sC, there is a literal s(⃗ c))
Ifqis a query, and ⃗tis a tuple, then we denote by q⃗tthe query
obtained by substituting the free variables of qwith⃗t
The problem of checking whether ⃗t∈cert(q,I,C)under sound
sources can be reduced to the problem of checking whether the
conjunctive query qCis contained in q⃗tunder the constraints
expressed by G ∪ M
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (92/199)

===== PAGE 118 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering vs query containment Part 2: Query answering and data exchange without constraints
Connection between query answering and containment
Definition
Query containment (under constraints) is the problem of checking
whether qD
1is contained in qD
2for every database D(satisfying the
constraints), where q1,q2are queries of the same arity
Query answering can be rephrased in terms of query containment:
A source database Ccan be represented as a conjunction qCof
ground literals over AS(e.g., if ⃗ c∈sC, there is a literal s(⃗ c))
Ifqis a query, and ⃗tis a tuple, then we denote by q⃗tthe query
obtained by substituting the free variables of qwith⃗t
The problem of checking whether ⃗t∈cert(q,I,C)under sound
sources can be reduced to the problem of checking whether the
conjunctive query qCis contained in q⃗tunder the constraints
expressed by G ∪ M
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (92/199)

===== PAGE 119 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering vs query containment Part 2: Query answering and data exchange without constraints
Query answering via query containment
Complexity of checking certain answers under sound sources:
Thecombined complexity is identical to the complexity of query
containment under constraints
Thedata complexity is the complexity of query containment under
constraints when the right-hand side query is considered fixed.
Hence, it is at most the complexity of query containment under
constraints
; Most results and techniques for query containment (under
constraints) are relevant also for query answering (under constraints)
Note: Also, query containment can be reduced to query answering.
However, (in the presence of constraints) we need to allow for constants
of the database to unify, i.e., to denote the same object.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (93/199)

===== PAGE 120 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering vs query containment Part 2: Query answering and data exchange without constraints
Query answering via query containment
Complexity of checking certain answers under sound sources:
Thecombined complexity is identical to the complexity of query
containment under constraints
Thedata complexity is the complexity of query containment under
constraints when the right-hand side query is considered fixed.
Hence, it is at most the complexity of query containment under
constraints
; Most results and techniques for query containment (under
constraints) are relevant also for query answering (under constraints)
Note: Also, query containment can be reduced to query answering.
However, (in the presence of constraints) we need to allow for constants
of the database to unify, i.e., to denote the same object.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (93/199)

===== PAGE 121 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
(G)LAV: Query answering vs query containment Part 2: Query answering and data exchange without constraints
Query answering via query containment
Complexity of checking certain answers under sound sources:
Thecombined complexity is identical to the complexity of query
containment under constraints
Thedata complexity is the complexity of query containment under
constraints when the right-hand side query is considered fixed.
Hence, it is at most the complexity of query containment under
constraints
; Most results and techniques for query containment (under
constraints) are relevant also for query answering (under constraints)
Note: Also, query containment can be reduced to query answering.
However, (in the presence of constraints) we need to allow for constants
of the database to unify, i.e., to denote the same object.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (93/199)

===== PAGE 122 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
Outline of Part 2
2Query answering in GAV without constraints
3Data exchange in (G)LAV without constraints
4Query answering in (G)LAV without constraints
(G)LAV and incompleteness
Approaches to query answering in (G)LAV
(G)LAV: Direct methods (aka view-based query answering)
(G)LAV: Query answering by (view-based) query rewriting
(G)LAV: Query answering vs query containment
More expressive queries?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (94/199)

===== PAGE 123 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – More expressive queries?
More expressive source queries in the mapping?
Same results about the direct algorithm hold if we use the relational
calculus as query language for the source queries in the mapping
More expressive queries over the global schema in the mapping?
Already positive queries lead to intractability
More expressive user queries?
With Datalog queries as user queries, computing certain answers
can be done in polynomial time
Even the simplest form of negation (inequalities) leads to
intractability
Ifrelational calculus is used as user query language, then
computing certain answers becomes undecidable
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (95/199)

===== PAGE 124 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – More expressive queries?
More expressive source queries in the mapping?
Same results about the direct algorithm hold if we use the relational
calculus as query language for the source queries in the mapping
More expressive queries over the global schema in the mapping?
Already positive queries lead to intractability
More expressive user queries?
With Datalog queries as user queries, computing certain answers
can be done in polynomial time
Even the simplest form of negation (inequalities) leads to
intractability
Ifrelational calculus is used as user query language, then
computing certain answers becomes undecidable
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (95/199)

===== PAGE 125 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – More expressive queries?
More expressive source queries in the mapping?
Same results about the direct algorithm hold if we use the relational
calculus as query language for the source queries in the mapping
More expressive queries over the global schema in the mapping?
Already positive queries lead to intractability
More expressive user queries?
With Datalog queries as user queries, computing certain answers
can be done in polynomial time
Even the simplest form of negation (inequalities) leads to
intractability
Ifrelational calculus is used as user query language, then
computing certain answers becomes undecidable
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (95/199)

===== PAGE 126 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – Intractability for positive views
From [van der Meyden TCS’93], by reduction from 3-colorability
We define the following LAV data integration system I=⟨G,S,M⟩:
G:edge(x, y),color(x, c) S:sE(x, y),sN(x)
M:sE(x, y);edge(x, y)
sN(x);color(x,RED)∨color(x,BLUE)∨color(x,GREEN )
Given a graph G= (N, E), we define the following source database C:
sEC={(a, b),(b, a)|(a, b)∈E} sNC={(a)|a∈N}
Consider the boolean query q:∃x, y, c. edge(x, y)∧color(x, c)∧color(y, c)
describing mismatched edge pairs:
IfGis 3-colorable, then ∃Bs.t.qB=false , hence cert(q,I,C) =false
IfGis not 3-colorable, then cert(q,I,C) =true
Theorem
Data complexity is coNP-hard for positive views and conjunctive queries
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (96/199)

===== PAGE 127 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – Intractability for positive views
From [van der Meyden TCS’93], by reduction from 3-colorability
We define the following LAV data integration system I=⟨G,S,M⟩:
G:edge(x, y),color(x, c) S:sE(x, y),sN(x)
M:sE(x, y);edge(x, y)
sN(x);color(x,RED)∨color(x,BLUE)∨color(x,GREEN )
Given a graph G= (N, E), we define the following source database C:
sEC={(a, b),(b, a)|(a, b)∈E} sNC={(a)|a∈N}
Consider the boolean query q:∃x, y, c. edge(x, y)∧color(x, c)∧color(y, c)
describing mismatched edge pairs:
IfGis 3-colorable, then ∃Bs.t.qB=false , hence cert(q,I,C) =false
IfGis not 3-colorable, then cert(q,I,C) =true
Theorem
Data complexity is coNP-hard for positive views and conjunctive queries
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (96/199)

===== PAGE 128 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – Intractability for positive views
From [van der Meyden TCS’93], by reduction from 3-colorability
We define the following LAV data integration system I=⟨G,S,M⟩:
G:edge(x, y),color(x, c) S:sE(x, y),sN(x)
M:sE(x, y);edge(x, y)
sN(x);color(x,RED)∨color(x,BLUE)∨color(x,GREEN )
Given a graph G= (N, E), we define the following source database C:
sEC={(a, b),(b, a)|(a, b)∈E} sNC={(a)|a∈N}
Consider the boolean query q:∃x, y, c. edge(x, y)∧color(x, c)∧color(y, c)
describing mismatched edge pairs:
IfGis 3-colorable, then ∃Bs.t.qB=false , hence cert(q,I,C) =false
IfGis not 3-colorable, then cert(q,I,C) =true
Theorem
Data complexity is coNP-hard for positive views and conjunctive queries
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (96/199)

===== PAGE 129 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – Intractability for positive views
From [van der Meyden TCS’93], by reduction from 3-colorability
We define the following LAV data integration system I=⟨G,S,M⟩:
G:edge(x, y),color(x, c) S:sE(x, y),sN(x)
M:sE(x, y);edge(x, y)
sN(x);color(x,RED)∨color(x,BLUE)∨color(x,GREEN )
Given a graph G= (N, E), we define the following source database C:
sEC={(a, b),(b, a)|(a, b)∈E} sNC={(a)|a∈N}
Consider the boolean query q:∃x, y, c. edge(x, y)∧color(x, c)∧color(y, c)
describing mismatched edge pairs:
IfGis 3-colorable, then ∃Bs.t.qB=false , hence cert(q,I,C) =false
IfGis not 3-colorable, then cert(q,I,C) =true
Theorem
Data complexity is coNP-hard for positive views and conjunctive queries
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (96/199)

===== PAGE 130 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – Intractability for positive views
From [van der Meyden TCS’93], by reduction from 3-colorability
We define the following LAV data integration system I=⟨G,S,M⟩:
G:edge(x, y),color(x, c) S:sE(x, y),sN(x)
M:sE(x, y);edge(x, y)
sN(x);color(x,RED)∨color(x,BLUE)∨color(x,GREEN )
Given a graph G= (N, E), we define the following source database C:
sEC={(a, b),(b, a)|(a, b)∈E} sNC={(a)|a∈N}
Consider the boolean query q:∃x, y, c. edge(x, y)∧color(x, c)∧color(y, c)
describing mismatched edge pairs:
IfGis 3-colorable, then ∃Bs.t.qB=false , hence cert(q,I,C) =false
IfGis not 3-colorable, then cert(q,I,C) =true
Theorem
Data complexity is coNP-hard for positive views and conjunctive queries
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (96/199)

===== PAGE 131 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – In coNP for positive views and queries
⃗t̸∈cert(q,I,C)if and only if there is a database BforIthat satisfies M
wrtC, and such that ⃗t̸∈qB
The mapping Mhas the form:
∀⃗ x.ϕS(⃗ x)→ ∃⃗ y1.α1(⃗ x, ⃗ y 1)∨ ··· ∨ ∃ ⃗ yhαh(⃗ x, ⃗ yh))
Hence, each tuple from Cforces the existence of ktuples in any database
that satisfies MwrtC, where kis the maximal length of conjunctions
αi(⃗ x, ⃗ yi)inM
Ifnare the tuples coming from C, then there is a db B′⊆ B forIthat
satisfies MwrtCwith at most n·ktuples. Since qis monotone, ⃗t̸∈qB′
Checking whether B′satisfies MwrtC, and checking whether ⃗t̸∈qB′
can be done in PTIME wrt the size of B′
Theorem
For positive views and queries, query answ. is coNP in data complexity
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (97/199)

===== PAGE 132 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – In coNP for positive views and queries
⃗t̸∈cert(q,I,C)if and only if there is a database BforIthat satisfies M
wrtC, and such that ⃗t̸∈qB
The mapping Mhas the form:
∀⃗ x.ϕS(⃗ x)→ ∃⃗ y1.α1(⃗ x, ⃗ y 1)∨ ··· ∨ ∃ ⃗ yhαh(⃗ x, ⃗ yh))
Hence, each tuple from Cforces the existence of ktuples in any database
that satisfies MwrtC, where kis the maximal length of conjunctions
αi(⃗ x, ⃗ yi)inM
Ifnare the tuples coming from C, then there is a db B′⊆ B forIthat
satisfies MwrtCwith at most n·ktuples. Since qis monotone, ⃗t̸∈qB′
Checking whether B′satisfies MwrtC, and checking whether ⃗t̸∈qB′
can be done in PTIME wrt the size of B′
Theorem
For positive views and queries, query answ. is coNP in data complexity
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (97/199)

===== PAGE 133 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – In coNP for positive views and queries
⃗t̸∈cert(q,I,C)if and only if there is a database BforIthat satisfies M
wrtC, and such that ⃗t̸∈qB
The mapping Mhas the form:
∀⃗ x.ϕS(⃗ x)→ ∃⃗ y1.α1(⃗ x, ⃗ y 1)∨ ··· ∨ ∃ ⃗ yhαh(⃗ x, ⃗ yh))
Hence, each tuple from Cforces the existence of ktuples in any database
that satisfies MwrtC, where kis the maximal length of conjunctions
αi(⃗ x, ⃗ yi)inM
Ifnare the tuples coming from C, then there is a db B′⊆ B forIthat
satisfies MwrtCwith at most n·ktuples. Since qis monotone, ⃗t̸∈qB′
Checking whether B′satisfies MwrtC, and checking whether ⃗t̸∈qB′
can be done in PTIME wrt the size of B′
Theorem
For positive views and queries, query answ. is coNP in data complexity
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (97/199)

===== PAGE 134 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – In coNP for positive views and queries
⃗t̸∈cert(q,I,C)if and only if there is a database BforIthat satisfies M
wrtC, and such that ⃗t̸∈qB
The mapping Mhas the form:
∀⃗ x.ϕS(⃗ x)→ ∃⃗ y1.α1(⃗ x, ⃗ y 1)∨ ··· ∨ ∃ ⃗ yhαh(⃗ x, ⃗ yh))
Hence, each tuple from Cforces the existence of ktuples in any database
that satisfies MwrtC, where kis the maximal length of conjunctions
αi(⃗ x, ⃗ yi)inM
Ifnare the tuples coming from C, then there is a db B′⊆ B forIthat
satisfies MwrtCwith at most n·ktuples. Since qis monotone, ⃗t̸∈qB′
Checking whether B′satisfies MwrtC, and checking whether ⃗t̸∈qB′
can be done in PTIME wrt the size of B′
Theorem
For positive views and queries, query answ. is coNP in data complexity
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (97/199)

===== PAGE 135 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – In coNP for positive views and queries
⃗t̸∈cert(q,I,C)if and only if there is a database BforIthat satisfies M
wrtC, and such that ⃗t̸∈qB
The mapping Mhas the form:
∀⃗ x.ϕS(⃗ x)→ ∃⃗ y1.α1(⃗ x, ⃗ y 1)∨ ··· ∨ ∃ ⃗ yhαh(⃗ x, ⃗ yh))
Hence, each tuple from Cforces the existence of ktuples in any database
that satisfies MwrtC, where kis the maximal length of conjunctions
αi(⃗ x, ⃗ yi)inM
Ifnare the tuples coming from C, then there is a db B′⊆ B forIthat
satisfies MwrtCwith at most n·ktuples. Since qis monotone, ⃗t̸∈qB′
Checking whether B′satisfies MwrtC, and checking whether ⃗t̸∈qB′
can be done in PTIME wrt the size of B′
Theorem
For positive views and queries, query answ. is coNP in data complexity
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (97/199)

===== PAGE 136 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – Data complexity of query answering
From [Abiteboul & Duschka PODS’98], for sound sources:
Global schema User queries
mapping query CQ CQ̸=PQ Datalog FOL
CQ PTIME coNP PTIME PTIME undec.
CQ̸=PTIME coNP PTIME PTIME undec.
PQ coNP coNP coNP coNP undec.
Datalog coNP undec. coNP undec. undec.
FOL undec. undec. undec. undec. undec.
An interesting issue (largely open): complexity of computing certain
answers in the case of exact GLAV mappings.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (98/199)

===== PAGE 137 =====

QA in GAV without constraints DE without constraints QA in (G)LAV without constraints
More expressive queries? Part 2: Query answering and data exchange without constraints
(G)LAV – Further references
Conjunctive queries using conjunctive views [Levy & al. PODS’95]
Inverse rules [Duschka & Genesereth PODS’97]
Bucket algorithm for query rewriting [Levy & al. AAAI’96]
MiniCon algorithm for query rewriting [Pottinger & Levy VLDB’00]
Recursive queries (Datalog programs) using conjunctive views
[Duschka & Genesereth PODS’97; Afrati & al. ICDT’99]
CQs with arithmetic comparison [Afrati & al. PODS’01]
Complexity analysis [Abiteboul & Duschka PODS’98; Grahne &
Mendelzon ICDT’99]
Variants of Regular Path Queries [Calvanese & al. ICDE’00,
PODS’00, DBPL’01, DBPL’08; Deutsch & Tannen DBPL’01],
Relationship between view-based rewriting and answering
[Calvanese & al. LICS’00, PODS’03, ICDT’05]
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (99/199)

===== PAGE 138 =====

Ontologies Ontology-based data integration in DL-Lite
Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
Introduction to ontologies
Description Logics
Query answering under different assumptions
TheDL-Lite family
6Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (100/199)

===== PAGE 139 =====

Ontologies Ontology-based data integration in DL-Lite
Introduction to ontologies Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
Introduction to ontologies
Description Logics
Query answering under different assumptions
TheDL-Lite family
6Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (101/199)

===== PAGE 140 =====

Ontologies Ontology-based data integration in DL-Lite
Introduction to ontologies Part 3: Ontology based data integration
Ontologies
Definition
Anontology is a representation scheme that describes a formal
conceptualization of a domain of interest.
The specification of an ontology comprises several levels, and in
particular:
Intensional level : specifies a set of conceptual elements and of
rules to describe the conceptual structures of the domain.
Extensional level : specifies a set of instances of the conceptual
elements described at the intensional level.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (102/199)

===== PAGE 141 =====

Ontologies Ontology-based data integration in DL-Lite
Introduction to ontologies Part 3: Ontology based data integration
Ontologies
Definition
Anontology is a representation scheme that describes a formal
conceptualization of a domain of interest.
The specification of an ontology comprises several levels, and in
particular:
Intensional level : specifies a set of conceptual elements and of
rules to describe the conceptual structures of the domain.
Extensional level : specifies a set of instances of the conceptual
elements described at the intensional level.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (102/199)

===== PAGE 142 =====

Ontologies Ontology-based data integration in DL-Lite
Introduction to ontologies Part 3: Ontology based data integration
The three levels of an ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (103/199)

===== PAGE 143 =====

Ontologies Ontology-based data integration in DL-Lite
Introduction to ontologies Part 3: Ontology based data integration
Intensional level of an ontology language
(The intensional level of) an Ontology is typically rendered as a
diagram (e.g., Semantic Network, Entity-Relationship schema, UML
Class Diagram).
Example: ontology rendered as UML Class Diagram
empCode: Integersalary: IntegerEmployee   Manager
  AreaManager TopManager1..*1..1boss projectName: StringProject1..*1..11..1worksFormanages1..*
{disjoint}
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (104/199)

===== PAGE 144 =====

Ontologies Ontology-based data integration in DL-Lite
Introduction to ontologies Part 3: Ontology based data integration
Extensional level of an ontology language
At the extensional level we have individuals and facts:
Aninstance represents an individual (or object) in the extension of
a concept.
e.g., instanceOf(riccardo, AssocProfessor)
Afact represents a relationship holding between instances.
e.g., worksFor(riccardo, SAPIENZA)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (105/199)

===== PAGE 145 =====

Ontologies Ontology-based data integration in DL-Lite
Introduction to ontologies Part 3: Ontology based data integration
Ontologies and Reasoning
Ontologies are logical theories , and several interpretations may
exist that satisfy them ( incomplete information )
m7
m6
m5
m3
m4
m2
m1=
ontology
Reasoning over ontologies amounts to make logical inference over
them
Intensional reasoning: concept/relationship satisfiability,
concept/relationship subsumption, etc.
Ontology reasoning: ontology satisfiability, instance checking, query
answering.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (106/199)

===== PAGE 146 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
Introduction to ontologies
Description Logics
Query answering under different assumptions
TheDL-Lite family
6Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (107/199)

===== PAGE 147 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
What are Description Logics?
Description Logics are logics specifically designed to represent and
reason on structured knowledge:
The domain is composed of objects and is structured into:
concepts, which correspond to classes, and denote sets of objects
roles, which correspond to (binary) relationships, and denote binary
relations on objects
The knowledge is asserted through so-called assertions, i.e., logical
axioms.
Description Logics are considered adequate for the logical specification
of ontologies
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (108/199)

===== PAGE 148 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Brief history of Description Logics
1977 KL-ONE Workshop: from Semantic Networks and Frames
to Description Logics
1984 Trade-off expressiveness – complexity of inference
[Brachman & al. 1984]
1986 Description logics for conceptual modeling
1989 Classic system – polynomial inference, but no assertions
1990 Expressive DLs – tableaux correspondence with modal
logic and PDLs automata
1995 Conceptual models fully captured in DLs
1998 Optimized tableaux make expressive DLs practical Query
answering in DLs
2000 Standardization efforts – OIL, DAML+OIL, OWL, OWL2
2005 Tractable DLs – EL,DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (109/199)

===== PAGE 149 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Description language
A description language indicates how to form concepts and roles, and is
characterized by a set of constructs for building complex concepts
androles starting from atomic ones.
Formal semantics is given in terms of interpretations.
Aninterpretation I= (∆I,·I)consists of:
a nonempty set ∆I, the domain of I
an interpretation function ·I, which maps
each individual cto an element cIof∆I
each atomic concept Ato a subset AIof∆I
each atomic role Pto a subset PIof∆I×∆I
The interpretation function is extended to complex concepts and roles
according to their syntactic structure.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (110/199)

===== PAGE 150 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Description language
A description language indicates how to form concepts and roles, and is
characterized by a set of constructs for building complex concepts
androles starting from atomic ones.
Formal semantics is given in terms of interpretations.
Aninterpretation I= (∆I,·I)consists of:
a nonempty set ∆I, the domain of I
an interpretation function ·I, which maps
each individual cto an element cIof∆I
each atomic concept Ato a subset AIof∆I
each atomic role Pto a subset PIof∆I×∆I
The interpretation function is extended to complex concepts and roles
according to their syntactic structure.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (110/199)

===== PAGE 151 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Concept constructors
Construct Syntax Example Semantics
atomic concept A Doctor AI⊆∆I
atomic role P hasChild PI⊆∆I×∆I
atomic negation ¬A ¬Doctor ∆I\AI
conjunction C⊓D Hum⊓Male CI∩DI
(unqual.) exist. res. ∃R ∃hasChild {o| ∃o′.(o, o′)∈RI}
value restriction ∀R.C∀hasChild .Male {o| ∀o′.(o, o′)∈RI→o′∈CI}
bottom ⊥ ∅
(C,Ddenote arbitrary concepts and Ran arbitrary role)
The above constructs form the basic language ALof the family of AL
languages.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (111/199)

===== PAGE 152 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Concept constructors
Construct Syntax Example Semantics
atomic concept A Doctor AI⊆∆I
atomic role P hasChild PI⊆∆I×∆I
atomic negation ¬A ¬Doctor ∆I\AI
conjunction C⊓D Hum⊓Male CI∩DI
(unqual.) exist. res. ∃R ∃hasChild {o| ∃o′.(o, o′)∈RI}
value restriction ∀R.C∀hasChild .Male {o| ∀o′.(o, o′)∈RI→o′∈CI}
bottom ⊥ ∅
(C,Ddenote arbitrary concepts and Ran arbitrary role)
The above constructs form the basic language ALof the family of AL
languages.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (111/199)

===== PAGE 153 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Additional concept and role constructors
Construct AL· Syntax Semantics
disjunction U C⊔D CI∪DI
top ⊤ ∆I
qual. exist. res. E ∃R.C {a| ∃b.(a, b)∈RI∧b∈CI}
(full) negation C ¬C ∆I\CI
number N (≥k R) {a|#{b|(a, b)∈RI} ≥k}
restrictions (≤k R) {a|#{b|(a, b)∈RI} ≤k}
qual. number Q (≥k R.C){a|#{b|(a, b)∈RI∧b∈CI} ≥k}
restrictions (≤k R.C){a|#{b|(a, b)∈RI∧b∈CI} ≤k}
inverse role I R−{(a, b)|(b, a)∈RI}
role closure reg R∗(RI)∗
Many different DL constructs and their combinations have been investigated.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (112/199)

===== PAGE 154 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Structural properties vs. asserted properties
We have seen how to build complex concept and roles expressions ,
which allow one to denote classes with a complex structure.
However, in order to represent real world domains, one needs the ability
toassert properties of classes and relationships between them (e.g., as
done in UML class diagrams).
The assertion of properties is done in DLs by means of an ontology (or
knowledge base).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (113/199)

===== PAGE 155 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Description Logics ontology (or knowledge base)
Is a pair O=⟨T,A⟩, where Tis aTBox andAis an ABox :
Description Logics TBox
Consists of a set of assertions on concepts and roles:
Inclusion assertions on concepts: C1⊑C2
Inclusion assertions on roles: R1⊑R2
Property assertions on (atomic) roles: e.g., (functional P)
Description Logics ABox
Consists of a set of membership assertions on individuals:
for concepts: A(c)
for roles: P(c1, c2) (we use cito denote individuals)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (114/199)

===== PAGE 156 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Description Logics ontology (or knowledge base)
Is a pair O=⟨T,A⟩, where Tis aTBox andAis an ABox :
Description Logics TBox
Consists of a set of assertions on concepts and roles:
Inclusion assertions on concepts: C1⊑C2
Inclusion assertions on roles: R1⊑R2
Property assertions on (atomic) roles: e.g., (functional P)
Description Logics ABox
Consists of a set of membership assertions on individuals:
for concepts: A(c)
for roles: P(c1, c2) (we use cito denote individuals)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (114/199)

===== PAGE 157 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Description Logics knowledge base – Example
Note: We use C1≡C2as an abbreviation for C1⊑C2, C 2⊑C1.
TBox assertions:
Inclusion assertions on concepts:
Father ≡Human ⊓Male⊓ ∃hasChild
HappyFather ⊑Father ⊓ ∀hasChild .HappyPerson
HappyAnc ⊑ ∀ descendant .HappyFather
Teacher ⊑ ¬ Doctor ⊓ ¬Lawyer
Inclusion assertions on roles:
hasChild ⊑descendant
Property assertions on roles:
(functional hasFather )
ABox membership assertions:
Teacher (mary), hasFather (mary,john), HappyAnc (john)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (115/199)

===== PAGE 158 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Description Logics knowledge base – Example
Note: We use C1≡C2as an abbreviation for C1⊑C2, C 2⊑C1.
TBox assertions:
Inclusion assertions on concepts:
Father ≡Human ⊓Male⊓ ∃hasChild
HappyFather ⊑Father ⊓ ∀hasChild .HappyPerson
HappyAnc ⊑ ∀ descendant .HappyFather
Teacher ⊑ ¬ Doctor ⊓ ¬Lawyer
Inclusion assertions on roles:
hasChild ⊑descendant
Property assertions on roles:
(functional hasFather )
ABox membership assertions:
Teacher (mary), hasFather (mary,john), HappyAnc (john)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (115/199)

===== PAGE 159 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Semantics of a Description Logics knowledge base
The semantics is given by specifying when an interpretation Isatisfies
an assertion:
C1⊑C2is satisfied by IifCI
1⊆CI
2.
R1⊑R2is satisfied by IifRI
1⊆RI
2.
A functional assertion (functional P)is satisfied by Iif the
relation PIis a (partial) function.
A(c)is satisfied by IifcI∈AI.
P(c1, c2)is satisfied by Iif(cI
1, cI
2)∈PI.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (116/199)

===== PAGE 160 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Models of a Description Logics ontology
Model of a DL knowledge base
An interpretation Iis amodel ofO=⟨T,A⟩if it satisfies all assertions
inTand all assertions in A.
Ois said to be satisfiable if it admits a model.
The fundamental reasoning service from which all other ones can be
easily derived is . . .
Logical implication
Ologically implies and assertion α, written O |=α, ifαis satisfied by
all models of O.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (117/199)

===== PAGE 161 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Models of a Description Logics ontology
Model of a DL knowledge base
An interpretation Iis amodel ofO=⟨T,A⟩if it satisfies all assertions
inTand all assertions in A.
Ois said to be satisfiable if it admits a model.
The fundamental reasoning service from which all other ones can be
easily derived is . . .
Logical implication
Ologically implies and assertion α, written O |=α, ifαis satisfied by
all models of O.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (117/199)

===== PAGE 162 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
TBox reasoning
Concept Satisfiability: Cis satisfiable wrt T, if there is a model
IofTsuch that CIis not empty, i.e., T ̸|=C≡ ⊥.
Subsumption: C1is subsumed by C2wrtT, if for every model I
ofTwe have CI
1⊆CI
2, i.e.,T |=C1⊑C2.
Equivalence: C1andC2are equivalent wrt Tif for every model I
ofTwe have CI
1=CI
2, i.e.,T |=C1≡C2.
Disjointness: C1andC2are disjoint wrt Tif for every model Iof
Twe have CI
1∩CI
2=∅, i.e.,T |=C1⊓C2≡ ⊥.
Analogous definitions hold for role satisfiability, subsumption,
equivalence, and disjointness.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (118/199)

===== PAGE 163 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Reasoning over a DL ontology
Ontology Satisfiability: Verify whether an ontology Ois
satisfiable, i.e., whether Oadmits at least one model.
Concept Instance Checking: Verify whether an individual cis an
instance of a concept CinO, i.e., whether O |=C(c).
Role Instance Checking: Verify whether a pair (c1, c2)of
individuals is an instance of a role RinO, i.e., whether
O |=R(c1, c2).
Query Answering: see later . . .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (119/199)

===== PAGE 164 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Complexity of reasoning over DL ontologies
Reasoning over DL ontologies is much more complex than reasoning
over concept expressions:
Bad news:
without restrictions on the form of TBox assertions, reasoning over
DL ontologies is already ExpTime-hard , even for very simple DLs.
Good news:
We can add a lot of expressivity (i.e., essentially all DL constructs
seen so far), while still staying within the ExpTime upper bound.
There are DL reasoners that perform reasonably well in practice for
such DLs (e.g, Racer, Pellet, Fact++, . . . )
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (120/199)

===== PAGE 165 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Complexity of reasoning over DL ontologies
Reasoning over DL ontologies is much more complex than reasoning
over concept expressions:
Bad news:
without restrictions on the form of TBox assertions, reasoning over
DL ontologies is already ExpTime-hard , even for very simple DLs.
Good news:
We can add a lot of expressivity (i.e., essentially all DL constructs
seen so far), while still staying within the ExpTime upper bound.
There are DL reasoners that perform reasonably well in practice for
such DLs (e.g, Racer, Pellet, Fact++, . . . )
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (120/199)

===== PAGE 166 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Relationship between DLs and ontology formalisms
Description Logics are nowadays advocated to provide the
foundations for ontology languages.
Different versions of the Web Ontology Language (OWL) have
been defined as syntactic variants of certain Description Logics.
DLs are also ideally suited to capture the fundamental features of
conceptual modeling formalims used in information systems design:
Entity-Relationship diagrams , used in database conceptual
modeling
UML Class Diagrams , used in the design phase of software
applications
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (121/199)

===== PAGE 167 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
DLs vs. OWL
DLs provide the foundations for standard ontology languages.
Different versions of the W3C standard Web Ontology Language
(OWL) have been defined as syntactic variants of certain DLs:
OWL Lite is a variant of the DL SHIF (D), where:
Sstands for ALC extended with transitive roles,
Hstands for role hierarchies (i.e., role inclusion assertions),
Istands for inverse roles,
Fstands for functionality of roles,
(D)stand for data types, which are necessary in any practical
knowledge representation language.
OWL DL is a variant of SHOIN (D), where:
Ostands for nominals, which means the possibility of using
individuals in the TBox (i.e., the intensional part of the ontology),
Nstands for (unqualified) number restrictions.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (122/199)

===== PAGE 168 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Description Logics vs. OWL2
A new version of OWL, OWL2 , has become a W3C standard in
November 2009.
The design aim of OWL2 was to address user requirements for
more expressivity of the language, while still preserving decidability
of reasoning.
OWL2 DL is a variant of SROIQ (D), which adds to OWL1 DL
several features:
qualified number restrictions ( Q)
regular role hierarchies ( R)
better treatment of datatypes
TheOWL2 profiles (OWL2 EL, OWL2 QL, and OWL2 RL) are
variant of specific DLs designed to have tractable reasoning.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (123/199)

===== PAGE 169 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
DL constructs vs. OWL constructs
OWL construct DL construct Example
ObjectIntersectionOf C1⊓ ··· ⊓ Cn Human ⊓Male
ObjectUnionOf C1⊔ ··· ⊔ Cn Doctor ⊔Lawyer
ObjectComplementOf ¬C ¬Male
ObjectOneOf {a1} ⊔ ··· ⊔ { an}{john} ⊔ { mary}
ObjectAllValuesFrom ∀P.C ∀hasChild .Doctor
ObjectSomeValuesFrom ∃P.C ∃hasChild .Lawyer
ObjectMaxCardinality (≤n P) (≤1hasChild )
ObjectMinCardinality (≥n P) (≥2hasChild )
···
Note: all constructs come also in the Data... instead of Object...
variant.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (124/199)

===== PAGE 170 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
DL axioms vs. OWL axioms
OWL axiom DL syntax Example
SubClassOf C1⊑C2 Human ⊑Animal ⊓Biped
EquivalentClasses C1≡C2 Man≡Human ⊓Male
DisjointClasses C1⊑ ¬C2 Man⊑ ¬Female
SameIndividual {a1} ≡ { a2}{presObama } ≡ { B.Obama }
DifferentIndividuals {a1} ⊑ ¬{ a2}{john} ⊑ ¬{ peter}
SubObjectPropertyOf P1⊑P2 hasDaughter ⊑hasChild
EquivalentObjectProperties P1≡P2 hasCost ≡hasPrice
InverseObjectProperties P1≡P−
2 hasChild ≡hasParent−
TransitiveObjectProperty P+⊑P ancestor+⊑ancestor
FunctionalObjectProperty (functional P)(functional hasFather )
···
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (125/199)

===== PAGE 171 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Ontology languages vs. query languages
Which query language to use?
Two extreme cases:
1Just classes and properties of the ontology ;instance checking
Ontology languages are tailored for capturing intensional
relationships.
They are quite poor as query languages :
Cannot refer to same object via multiple navigation paths in the
ontology, i.e., allow only for a limited form of join, namely chaining.
2Full SQL (or equivalently, first-order logic)
Problem: in the presence of incomplete information, query answering
becomes undecidable (FOL validity).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (126/199)

===== PAGE 172 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Ontology languages vs. query languages
Which query language to use?
Two extreme cases:
1Just classes and properties of the ontology ;instance checking
Ontology languages are tailored for capturing intensional
relationships.
They are quite poor as query languages :
Cannot refer to same object via multiple navigation paths in the
ontology, i.e., allow only for a limited form of join, namely chaining.
2Full SQL (or equivalently, first-order logic)
Problem: in the presence of incomplete information, query answering
becomes undecidable (FOL validity).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (126/199)

===== PAGE 173 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Ontology languages vs. query languages
Which query language to use?
Two extreme cases:
1Just classes and properties of the ontology ;instance checking
Ontology languages are tailored for capturing intensional
relationships.
They are quite poor as query languages :
Cannot refer to same object via multiple navigation paths in the
ontology, i.e., allow only for a limited form of join, namely chaining.
2Full SQL (or equivalently, first-order logic)
Problem: in the presence of incomplete information, query answering
becomes undecidable (FOL validity).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (126/199)

===== PAGE 174 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Conjunctive queries (CQs)
Aconjunctive query (CQ) is a first-order query of the form
q(⃗ x)← ∃⃗ y.R1(⃗ x, ⃗ y)∧ ··· ∧ Rk(⃗ x, ⃗ y)
where each Ri(⃗ x, ⃗ y)is an atom using (some of) the free variables ⃗ x, the
existentially quantified variables ⃗ y, and possibly constants.
We will also use the simpler Datalog notation:
q(⃗ x)←R1(⃗ x, ⃗ y), . . . , R k(⃗ x, ⃗ y)
CQs contain no disjunction, no negation, no universal
quantification.
Correspond to SQL/relational algebra select-project-join (SPJ)
queries – the most frequently asked queries.
They can also be written as SPARQL queries.
A Boolean CQ is a CQ without free variables ⇒
q()← ∃⃗ y.R1(⃗ y)∧ ··· ∧ Rk(⃗ y).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (127/199)

===== PAGE 175 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Example of conjunctive query
Professor ⊑Faculty
AssocProf ⊑Professor
Dean ⊑Professor
AssocProf ⊑ ¬ Dean
Faculty ⊑ ∃ age
∃age−⊑Integer
∃worksFor ⊑Faculty
∃worksFor−⊑College
Faculty ⊑ ∃ worksFor
College ⊑ ∃ worksFor−
...
empCode: Integersalary: IntegerEmployee   Manager
  AreaManager TopManager1..*1..1boss projectName: StringProject1..*1..11..1worksFormanages1..*
{disjoint}
q(nf,af,nd)← ∃ f, c, d, ad.
worksFor (f, c)∧isHeadOf (d, c)∧name (f,nf)∧name (d,nd)∧
age(f,af)∧age(d,ad)∧af=ad
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (128/199)

===== PAGE 176 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Example of conjunctive query
Professor ⊑Faculty
AssocProf ⊑Professor
Dean ⊑Professor
AssocProf ⊑ ¬ Dean
Faculty ⊑ ∃ age
∃age−⊑Integer
∃worksFor ⊑Faculty
∃worksFor−⊑College
Faculty ⊑ ∃ worksFor
College ⊑ ∃ worksFor−
...
empCode: Integersalary: IntegerEmployee   Manager
  AreaManager TopManager1..*1..1boss projectName: StringProject1..*1..11..1worksFormanages1..*
{disjoint}
q(nf,af,nd)← ∃ f, c, d, ad.
worksFor (f, c)∧isHeadOf (d, c)∧name (f,nf)∧name (d,nd)∧
age(f,af)∧age(d,ad)∧af=ad
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (128/199)

===== PAGE 177 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Example of conjunctive query
Professor ⊑Faculty
AssocProf ⊑Professor
Dean ⊑Professor
AssocProf ⊑ ¬ Dean
Faculty ⊑ ∃ age
∃age−⊑Integer
∃worksFor ⊑Faculty
∃worksFor−⊑College
Faculty ⊑ ∃ worksFor
College ⊑ ∃ worksFor−
...
empCode: Integersalary: IntegerEmployee   Manager
  AreaManager TopManager1..*1..1boss projectName: StringProject1..*1..11..1worksFormanages1..*
{disjoint}
q(nf,af,nd)← ∃ f, c, d, ad.
worksFor (f, c)∧isHeadOf (d, c)∧name (f,nf)∧name (d,nd)∧
age(f,af)∧age(d,ad)∧af=ad
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (128/199)

===== PAGE 178 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Example of conjunctive query
Professor ⊑Faculty
AssocProf ⊑Professor
Dean ⊑Professor
AssocProf ⊑ ¬ Dean
Faculty ⊑ ∃ age
∃age−⊑Integer
∃worksFor ⊑Faculty
∃worksFor−⊑College
Faculty ⊑ ∃ worksFor
College ⊑ ∃ worksFor−
...
empCode: Integersalary: IntegerEmployee   Manager
  AreaManager TopManager1..*1..1boss projectName: StringProject1..*1..11..1worksFormanages1..*
{disjoint}
q(nf,af,nd)← ∃ f, c, d, ad.
worksFor (f, c)∧isHeadOf (d, c)∧name (f,nf)∧name (d,nd)∧
age(f,af)∧age(d,ad)∧af=ad
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (128/199)

===== PAGE 179 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Conjunctive queries and SQL – Example
Relational alphabet:
worksFor (fac,coll), isHeadOf (dean,coll), name (p,n), age (p,a)
Query: return name, age, and name of dean of all faculty that have the
same age as their dean.Expressed in SQL:
SELECT NF.name, AF.age, ND.name
FROM worksFor W, isHeadOf H, name NF, name ND, age AF, age AD
WHERE W.fac = NF.p AND W.fac = AF.p AND
H.dean = ND.p AND H.dean = AD.p AND
W.coll = H.coll AND AF.a = AD.a
Expressed as a CQ:
q(nf,af,nd)←worksFor (f1,c1),isHeadOf (d1,c2),
name (f2,nf),name (d2,nd),age(f3,af),age(d3,ad),
f1=f2,f1=f3,d1=d2,d1=d3,c1=c2,af=ad
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (129/199)

===== PAGE 180 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Conjunctive queries and SQL – Example
Relational alphabet:
worksFor (fac,coll), isHeadOf (dean,coll), name (p,n), age (p,a)
Query: return name, age, and name of dean of all faculty that have the
same age as their dean.
Expressed in SQL:
SELECT NF.name, AF.age, ND.name
FROM worksFor W, isHeadOf H, name NF, name ND, age AF, age AD
WHERE W.fac = NF.p AND W.fac = AF.p AND
H.dean = ND.p AND H.dean = AD.p AND
W.coll = H.coll AND AF.a = AD.aExpressed as a CQ:
q(nf,af,nd)←worksFor (f1,c1),isHeadOf (d1,c2),
name (f2,nf),name (d2,nd),age(f3,af),age(d3,ad),
f1=f2,f1=f3,d1=d2,d1=d3,c1=c2,af=ad
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (129/199)

===== PAGE 181 =====

Ontologies Ontology-based data integration in DL-Lite
Description Logics Part 3: Ontology based data integration
Conjunctive queries and SQL – Example
Relational alphabet:
worksFor (fac,coll), isHeadOf (dean,coll), name (p,n), age (p,a)
Query: return name, age, and name of dean of all faculty that have the
same age as their dean.
Expressed in SQL:
SELECT NF.name, AF.age, ND.name
FROM worksFor W, isHeadOf H, name NF, name ND, age AF, age AD
WHERE W.fac = NF.p AND W.fac = AF.p AND
H.dean = ND.p AND H.dean = AD.p AND
W.coll = H.coll AND AF.a = AD.a
Expressed as a CQ:
q(nf,af,nd)←worksFor (f1,c1),isHeadOf (d1,c2),
name (f2,nf),name (d2,nd),age(f3,af),age(d3,ad),
f1=f2,f1=f3,d1=d2,d1=d3,c1=c2,af=ad
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (129/199)

===== PAGE 182 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
Introduction to ontologies
Description Logics
Query answering under different assumptions
TheDL-Lite family
6Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (130/199)

===== PAGE 183 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under different assumptions
There are fundamentally different assumptions when addressing query
answering in different settings:
traditional database assumption
knowledge representation assumption
Note: for the moment we assume to deal with an ordinary ABox, which
however may be very large and thus is stored in a database.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (131/199)

===== PAGE 184 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under different assumptions
There are fundamentally different assumptions when addressing query
answering in different settings:
traditional database assumption
knowledge representation assumption
Note: for the moment we assume to deal with an ordinary ABox, which
however may be very large and thus is stored in a database.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (131/199)

===== PAGE 185 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the database assumption
Data are completely specified (CWA), and typically large.
Schema/intensional information used in the design phase.
Atruntime , the data is assumed to satisfy the schema, and
therefore the schema is not used .
Queries allow for complex navigation paths in the data (cf. SQL).
;Query answering amounts to query evaluation , which is
computationally easy.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (132/199)

===== PAGE 186 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the database assumption (cont’d)
DataSourceLogicalSchema
Schema /Ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (133/199)

===== PAGE 187 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the database assumption (cont’d)
ResultQuery
DataSourceLogicalSchema
Schema /Ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (133/199)

===== PAGE 188 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the database assumption (cont’d)
Reasoning
ResultQuery
DataSourceLogicalSchema
Schema /Ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (133/199)

===== PAGE 189 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the database assumption – Example
  ProfessorCollegeworksFor Faculty
For each class/property we have a (complete) table in the database.
DB: Faculty = {john ,mary ,paul}
Professor = {john ,paul}
College = {collA ,collB }
worksFor = {(john ,collA ), (mary ,collB )}
Query: q(x)← ∃ c.Professor (x),College (c),worksFor (x, c)
Answer: ???{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (134/199)

===== PAGE 190 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the database assumption – Example
  ProfessorCollegeworksFor Faculty
For each class/property we have a (complete) table in the database.
DB: Faculty = {john ,mary ,paul}
Professor = {john ,paul}
College = {collA ,collB }
worksFor = {(john ,collA ), (mary ,collB )}
Query: q(x)← ∃ c.Professor (x),College (c),worksFor (x, c)
Answer: ???{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (134/199)

===== PAGE 191 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the database assumption – Example
  ProfessorCollegeworksFor Faculty
For each class/property we have a (complete) table in the database.
DB: Faculty = {john ,mary ,paul}
Professor = {john ,paul}
College = {collA ,collB }
worksFor = {(john ,collA ), (mary ,collB )}
Query: q(x)← ∃ c.Professor (x),College (c),worksFor (x, c)
Answer: {john}{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (134/199)

===== PAGE 192 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption
An ontology imposes constraints on the data.
Actual data may be incomplete or inconsistent w.r.t. such
constraints.
The system has to take into account the constraints during query
answering, and overcome incompleteness or inconsistency.
;Query answering amounts to logical inference , which is
computationally more costly.
Note:
Size of the data is not considered critical (comparable to the size of the
intensional information).
Queries are typically simple, i.e., atomic (a class name), and query
answering amounts to instance checking.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (135/199)

===== PAGE 193 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption (cont’d)
QueryResult
Reasoning
DataSourceLogicalSchema
Schema /Ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (136/199)

===== PAGE 194 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption (cont’d)
Reasoning
QueryResult
Reasoning
DataSourceLogicalSchema
Schema /Ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (136/199)

===== PAGE 195 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption – Example
  ProfessorCollegeworksFor Faculty
The tables in the database may be incompletely specified , or even
missing for some classes/properties.
DB: Professor ⊇ {john ,paul}
College ⊇ {collA ,collB }
worksFor ⊇ {(john ,collA ), (mary ,collB )}
Query: q(x)←Faculty (x)
Answer: ???{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (137/199)

===== PAGE 196 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption – Example
  ProfessorCollegeworksFor Faculty
The tables in the database may be incompletely specified , or even
missing for some classes/properties.
DB: Professor ⊇ {john ,paul}
College ⊇ {collA ,collB }
worksFor ⊇ {(john ,collA ), (mary ,collB )}
Query: q(x)←Faculty (x)
Answer: {john ,paul ,mary}{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (137/199)

===== PAGE 197 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption – Example 2
 Person hasFather1..*
Each person has a father, who is a person.
DB: Person ⊇ {john ,paul ,toni}
hasFather ⊇ {(john ,paul ), (paul ,toni )}
Queries: q1(x, y)←hasFather (x, y)
q2(x)← ∃y.hasFather (x, y)
q3(x)← ∃y1, y2, y3.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
q4(x, y3)← ∃y1, y2.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
Answers: to q1: ???{
toq2: ???{
toq3: ???{
toq4: ???{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (138/199)

===== PAGE 198 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption – Example 2
 Person hasFather1..*
Each person has a father, who is a person.
DB: Person ⊇ {john ,paul ,toni}
hasFather ⊇ {(john ,paul ), (paul ,toni )}
Queries: q1(x, y)←hasFather (x, y)
q2(x)← ∃y.hasFather (x, y)
q3(x)← ∃y1, y2, y3.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
q4(x, y3)← ∃y1, y2.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
Answers: to q1:{(john ,paul ), (paul ,toni )}{
toq2: ???{
toq3: ???{
toq4: ???{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (138/199)

===== PAGE 199 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption – Example 2
 Person hasFather1..*
Each person has a father, who is a person.
DB: Person ⊇ {john ,paul ,toni}
hasFather ⊇ {(john ,paul ), (paul ,toni )}
Queries: q1(x, y)←hasFather (x, y)
q2(x)← ∃y.hasFather (x, y)
q3(x)← ∃y1, y2, y3.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
q4(x, y3)← ∃y1, y2.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
Answers: to q1:{(john ,paul ), (paul ,toni )}{
toq2:{john ,paul ,toni}{
toq3: ???{
toq4: ???{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (138/199)

===== PAGE 200 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption – Example 2
 Person hasFather1..*
Each person has a father, who is a person.
DB: Person ⊇ {john ,paul ,toni}
hasFather ⊇ {(john ,paul ), (paul ,toni )}
Queries: q1(x, y)←hasFather (x, y)
q2(x)← ∃y.hasFather (x, y)
q3(x)← ∃y1, y2, y3.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
q4(x, y3)← ∃y1, y2.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
Answers: to q1:{(john ,paul ), (paul ,toni )}{
toq2:{john ,paul ,toni}{
toq3:{john ,paul ,toni}{
toq4: ???{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (138/199)

===== PAGE 201 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering under the KR assumption – Example 2
 Person hasFather1..*
Each person has a father, who is a person.
DB: Person ⊇ {john ,paul ,toni}
hasFather ⊇ {(john ,paul ), (paul ,toni )}
Queries: q1(x, y)←hasFather (x, y)
q2(x)← ∃y.hasFather (x, y)
q3(x)← ∃y1, y2, y3.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
q4(x, y3)← ∃y1, y2.hasFather (x, y1),hasFather (y1, y2),hasFather (y2, y3)
Answers: to q1:{(john ,paul ), (paul ,toni )}{
toq2:{john ,paul ,toni}{
toq3:{john ,paul ,toni}{
toq4:{ }{
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (138/199)

===== PAGE 202 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
QA under the KR assumption – Andrea’s Example
 Faculty   Professor  AssocProf  FullProfisAdvisedBy {disjoint, complete}ofﬁceMate
Professor ≡AssocProf ⊔FullProf
Faculty ⊇ { andrea ,paul ,mary ,john}
Professor ⊇ { andrea ,paul ,mary}
AssocProf ⊇ { paul}
FullProf ⊇ { mary}
isAdvisedBy ⊇ {(john ,andrea ), (john ,mary )}
officeMate ⊇ {(mary ,andrea ), (andrea ,paul )}
johnandrea:Professormary:FullProfofﬁceMateisAdvisedByisAdvisedBypaul:AssocProfofﬁceMate
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (139/199)

===== PAGE 203 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
QA under the KR assumption – Andrea’s Example (cont’d)
 Faculty   Professor  AssocProf  FullProfisAdvisedBy {disjoint, complete}ofﬁceMate
johnandrea:Professormary:FullProfofﬁceMateisAdvisedByisAdvisedBypaul:AssocProfofﬁceMate
q()← ∃ y, z.
isAdvisedBy (john, y),FullProf (y),
officeMate (y, z),AssocProf (z)
Answer: yes or no?To determine this answer, we need to resort to reasoning by cases .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (140/199)

===== PAGE 204 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
QA under the KR assumption – Andrea’s Example (cont’d)
 Faculty   Professor  AssocProf  FullProfisAdvisedBy {disjoint, complete}ofﬁceMate
johnandrea:Professormary:FullProfofﬁceMateisAdvisedByisAdvisedBypaul:AssocProfofﬁceMate
q()← ∃ y, z.
isAdvisedBy (john, y),FullProf (y),
officeMate (y, z),AssocProf (z)
Answer: yes or no?To determine this answer, we need to resort to reasoning by cases .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (140/199)

===== PAGE 205 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
QA under the KR assumption – Andrea’s Example (cont’d)
 Faculty   Professor  AssocProf  FullProfisAdvisedBy {disjoint, complete}ofﬁceMate
johnandrea:Professormary:FullProfofﬁceMateisAdvisedByisAdvisedBypaul:AssocProfofﬁceMate
q()← ∃ y, z.
isAdvisedBy (john, y),FullProf (y),
officeMate (y, z),AssocProf (z)
Answer: yes!
To determine this answer, we need to resort to reasoning by cases .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (140/199)

===== PAGE 206 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query answering when accessing data through ontologies
We have to face the difficulties of both DB and KB assumptions:
The actual data is stored in external information sources (i.e.,
databases), and thus its size is typically very large .
The ontology introduces incompleteness of information, and we
have to do logical inference, rather than query evaluation.
We want to take into account at runtime theconstraints
expressed in the ontology.
We want to answer complex database-like queries .
We may have to deal with multiple information sources, and thus
face also the problems that are typical of data integration.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (141/199)

===== PAGE 207 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Certain answers to a query
LetO=⟨T,A⟩be an ontology, Ian interpretation for O, and
q(⃗ x)← ∃⃗ y.conj(⃗ x, ⃗ y)a CQ.
Def.: The answer toq(⃗ x)overI, denoted qI
. . . is the set of tuples ⃗ cof constants of Asuch that the formula
∃⃗ y.conj(⃗ c, ⃗ y)evaluates to true in I.
We are interested in those answers that hold in all models of an
ontology.
Def.: The certain answers toq(⃗ x)overO=⟨T,A⟩, denoted
cert(q,O)
. . . are the tuples ⃗ cof constants of Asuch that ⃗ c∈qI, for every
model IofO.
Note: when qis boolean, we write O |=qiffqevaluates to true in every
model IofO,O ̸|=qotherwise.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (142/199)

===== PAGE 208 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Certain answers to a query
LetO=⟨T,A⟩be an ontology, Ian interpretation for O, and
q(⃗ x)← ∃⃗ y.conj(⃗ x, ⃗ y)a CQ.
Def.: The answer toq(⃗ x)overI, denoted qI
. . . is the set of tuples ⃗ cof constants of Asuch that the formula
∃⃗ y.conj(⃗ c, ⃗ y)evaluates to true in I.
We are interested in those answers that hold in all models of an
ontology.
Def.: The certain answers toq(⃗ x)overO=⟨T,A⟩, denoted
cert(q,O)
. . . are the tuples ⃗ cof constants of Asuch that ⃗ c∈qI, for every
model IofO.
Note: when qis boolean, we write O |=qiffqevaluates to true in every
model IofO,O ̸|=qotherwise.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (142/199)

===== PAGE 209 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Certain answers to a query
LetO=⟨T,A⟩be an ontology, Ian interpretation for O, and
q(⃗ x)← ∃⃗ y.conj(⃗ x, ⃗ y)a CQ.
Def.: The answer toq(⃗ x)overI, denoted qI
. . . is the set of tuples ⃗ cof constants of Asuch that the formula
∃⃗ y.conj(⃗ c, ⃗ y)evaluates to true in I.
We are interested in those answers that hold in all models of an
ontology.
Def.: The certain answers toq(⃗ x)overO=⟨T,A⟩, denoted
cert(q,O)
. . . are the tuples ⃗ cof constants of Asuch that ⃗ c∈qI, for every
model IofO.
Note: when qis boolean, we write O |=qiffqevaluates to true in every
model IofO,O ̸|=qotherwise.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (142/199)

===== PAGE 210 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Data complexity
Various parameters affect the complexity of query answering over an
ontology.
Depending on which parameters we consider, we get different
complexity measures:
Data complexity : only the size of the ABox (i.e., the data)
matters.
TBox and query are considered fixed.
Schema complexity : only the size of the TBox (i.e., the schema)
matters.
ABox and query are considered fixed.
Combined complexity : no parameter is considered fixed.
In the integration setting, the size of the data largely dominates the
size of the conceptual layer (and of the query).
; Data complexity is the relevant complexity measure.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (143/199)

===== PAGE 211 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Data complexity
Various parameters affect the complexity of query answering over an
ontology.
Depending on which parameters we consider, we get different
complexity measures:
Data complexity : only the size of the ABox (i.e., the data)
matters.
TBox and query are considered fixed.
Schema complexity: only the size of the TBox (i.e., the schema)
matters.
ABox and query are considered fixed.
Combined complexity: no parameter is considered fixed.
In the integration setting, the size of the data largely dominates the
size of the conceptual layer (and of the query).
; Data complexity is the relevant complexity measure.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (143/199)

===== PAGE 212 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Inference in query answering
cert(q,⟨T,˚A⟩)Logical inferenceq
˚AT
To be able to deal with data efficiently, we need to separate the
contribution of Afrom the contribution of qandT.
;Query answering by query rewriting .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (144/199)

===== PAGE 213 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query rewriting
rewritingPerfect
(under OWA)
Query
(under CWA)evaluationq
T
˚A cert(q,⟨T,˚A⟩)rewq,T
Query answering can always be thought as done in two phases:
1Perfect rewriting : produce from qand the TBox Ta new query
rq,T(called the perfect rewriting of qw.r.t.T).
2Query evaluation : evaluate rq,Tover the ABox Aseen as a
complete database (and without considering the TBox T).
; Produces cert(q,⟨T,A⟩).
Note: The “always” holds if we pose no restriction on the language in which to
express the rewriting rq,T.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (145/199)

===== PAGE 214 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query rewriting (cont’d)
Reasoning
QueryResult
Reasoning
DataSourceLogicalSchema
Schema /Ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (146/199)

===== PAGE 215 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Query rewriting (cont’d)
Reasoning
Rewritten Query
QueryResult
Reasoning
DataSourceLogicalSchema
Schema /Ontology
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (146/199)

===== PAGE 216 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Language of the rewriting
The expressiveness of the ontology language affects the query
language into which we are able to rewrite CQs :
When we can rewrite into FOL/SQL .
;Query evaluation can be done in SQL, i.e., via an RDBMS
(Note: FOL is in LogSpace ).
When we can rewrite into an NLogSpace -hard language.
;Query evaluation requires (at least) linear recursion.
When we can rewrite into a PTime -hard language.
;Query evaluation requires full recursion (e.g., Datalog).
When we can rewrite into a coNP -hard language.
;Query evaluation requires (at least) power of Disjunctive
Datalog.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (147/199)

===== PAGE 217 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Language of the rewriting
The expressiveness of the ontology language affects the query
language into which we are able to rewrite CQs :
When we can rewrite into FOL/SQL .
;Query evaluation can be done in SQL, i.e., via an RDBMS
(Note: FOL is in LogSpace ).
When we can rewrite into an NLogSpace -hard language.
;Query evaluation requires (at least) linear recursion.
When we can rewrite into a PTime -hard language.
;Query evaluation requires full recursion (e.g., Datalog).
When we can rewrite into a coNP -hard language.
;Query evaluation requires (at least) power of Disjunctive
Datalog.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (147/199)

===== PAGE 218 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Language of the rewriting
The expressiveness of the ontology language affects the query
language into which we are able to rewrite CQs :
When we can rewrite into FOL/SQL .
;Query evaluation can be done in SQL, i.e., via an RDBMS
(Note: FOL is in LogSpace ).
When we can rewrite into an NLogSpace -hard language.
;Query evaluation requires (at least) linear recursion.
When we can rewrite into a PTime -hard language.
;Query evaluation requires full recursion (e.g., Datalog).
When we can rewrite into a coNP -hard language.
;Query evaluation requires (at least) power of Disjunctive
Datalog.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (147/199)

===== PAGE 219 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Language of the rewriting
The expressiveness of the ontology language affects the query
language into which we are able to rewrite CQs :
When we can rewrite into FOL/SQL .
;Query evaluation can be done in SQL, i.e., via an RDBMS
(Note: FOL is in LogSpace ).
When we can rewrite into an NLogSpace -hard language.
;Query evaluation requires (at least) linear recursion.
When we can rewrite into a PTime -hard language.
;Query evaluation requires full recursion (e.g., Datalog).
When we can rewrite into a coNP -hard language.
;Query evaluation requires (at least) power of Disjunctive
Datalog.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (147/199)

===== PAGE 220 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Complexity of query answering in DLs
Problem of rewriting is related to complexity of query answering .
Studied extensively for (unions of) CQs and various ontology languages:
Combined complexity Data complexity
Plain databases NP-complete inLogSpace(2)
OWL 2 (and less) 2ExpTime -complete coNP -hard(1)
(1)Already for a TBox with a single disjunction (see Andrea’s example).
(2)This is what we need to scale with the data.
Questions
Can we find interesting families of DLs for which the query
answering problem can be solved efficiently (i.e., in LogSpace )?
If yes, can we leverage relational database technology for query
answering?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (148/199)

===== PAGE 221 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Complexity of query answering in DLs
Problem of rewriting is related to complexity of query answering .
Studied extensively for (unions of) CQs and various ontology languages:
Combined complexity Data complexity
Plain databases NP-complete inLogSpace(2)
OWL 2 (and less) 2ExpTime -complete coNP -hard(1)
(1)Already for a TBox with a single disjunction (see Andrea’s example).
(2)This is what we need to scale with the data.
Questions
Can we find interesting families of DLs for which the query
answering problem can be solved efficiently (i.e., in LogSpace )?
If yes, can we leverage relational database technology for query
answering?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (148/199)

===== PAGE 222 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Complexity of query answering in DLs
Problem of rewriting is related to complexity of query answering .
Studied extensively for (unions of) CQs and various ontology languages:
Combined complexity Data complexity
Plain databases NP-complete inLogSpace(2)
OWL 2 (and less) 2ExpTime -complete coNP -hard(1)
(1)Already for a TBox with a single disjunction (see Andrea’s example).
(2)This is what we need to scale with the data.
Questions
Can we find interesting families of DLs for which the query
answering problem can be solved efficiently (i.e., in LogSpace )?
If yes, can we leverage relational database technology for query
answering?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (148/199)

===== PAGE 223 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering under different assumptions Part 3: Ontology based data integration
Complexity of query answering in DLs
Problem of rewriting is related to complexity of query answering .
Studied extensively for (unions of) CQs and various ontology languages:
Combined complexity Data complexity
Plain databases NP-complete inLogSpace(2)
OWL 2 (and less) 2ExpTime -complete coNP -hard(1)
(1)Already for a TBox with a single disjunction (see Andrea’s example).
(2)This is what we need to scale with the data.
Questions
Can we find interesting families of DLs for which the query
answering problem can be solved efficiently (i.e., in LogSpace )?
If yes, can we leverage relational database technology for query
answering?
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (148/199)

===== PAGE 224 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
Introduction to ontologies
Description Logics
Query answering under different assumptions
TheDL-Lite family
6Ontology-based data integration in DL-Lite
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (149/199)

===== PAGE 225 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
The DL-Lite family
A family of DLs optimized according to the tradeoff between
expressive power and complexity of query answering, with
emphasis on data .
Carefully designed to have nice computational properties for
answering UCQs (i.e., computing certain answers):
The same complexity as relational databases.
In fact, query answering can be delegated to a relational DB engine.
The DLs of the DL-Lite family are essentially the maximally
expressive ontology languages enjoying these nice computational
properties.
We present DL-Lite A, an expressive member of the DL-Lite family.
DL-Lite Aprovides robust foundations for Ontology-Based Data Access.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (150/199)

===== PAGE 226 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
The DL-Lite family
A family of DLs optimized according to the tradeoff between
expressive power and complexity of query answering, with
emphasis on data .
Carefully designed to have nice computational properties for
answering UCQs (i.e., computing certain answers):
The same complexity as relational databases.
In fact, query answering can be delegated to a relational DB engine.
The DLs of the DL-Lite family are essentially the maximally
expressive ontology languages enjoying these nice computational
properties.
We present DL-Lite A, an expressive member of the DL-Lite family.
DL-Lite Aprovides robust foundations for Ontology-Based Data Access.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (150/199)

===== PAGE 227 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
DL-Lite Aontologies
TBox assertions:
Class (concept) inclusion assertions: B⊑C, with:
B−→ A| ∃Q
C−→ B| ¬B
Property (role) inclusion assertions: Q⊑R, with:
Q−→ P|P−
R−→ Q| ¬Q
Functionality assertions: (funct Q)
Proviso: functional properties cannot be specialized.
ABox assertions: A(c),P(c1, c2), with c1,c2constants
Note: DL-Lite Adistinguishes also between object and data properties
(ignored here).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (151/199)

===== PAGE 228 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Semantics of DL-Lite A
Construct Syntax Example Semantics
atomic conc. A Doctor AI⊆∆I
exist. restr. ∃Q ∃child−{d| ∃e.(d, e)∈QI}
at. conc. neg. ¬A ¬Doctor ∆I\AI
conc. neg. ¬∃Q ¬∃child ∆I\(∃Q)I
atomic role P child PI⊆∆I×∆I
inverse role P−child−{(o, o′)|(o′, o)∈PI}
role negation ¬Q ¬manages (∆I×∆I)\QI
conc. incl. B⊑C Father ⊑ ∃child BI⊆CI
role incl. Q⊑R hasFather ⊑child−QI⊆RI
funct. asser. (funct Q) (funct succ) ∀d, e, e′.(d, e)∈QI∧(d, e′)∈QI→e=e′
mem. asser. A(c) Father (bob) cI∈AI
mem. asser. P(c1, c2) child(bob,ann) (cI
1, cI
2)∈PI
DL-Lite A(as all DLs of the DL-Lite family) adopts the Unique Name
Assumption (UNA), i.e., different individuals denote different objects.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (152/199)

===== PAGE 229 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Capturing basic ontology constructs in DL-Lite A
ISA between classes A1⊑A2
Disjointness between classes A1⊑ ¬A2
Domain and range of properties ∃P⊑A1∃P−⊑A2
Mandatory participation (min card = 1) A1⊑ ∃P A 2⊑ ∃P−
Functionality of relations (max card = 1) (funct P) (funct P−)
ISA between properties Q1⊑Q2
Disjointness between properties Q1⊑ ¬Q2
Note 1: DL-Lite Acannot capture completeness of a hierarchy. This
would require disjunction (i.e., OR).
Note2: DL-Lite Acan be extended to capture also min cardinality
constraints (A⊑≤nQ) and max cardinality constraints (A⊑≥nQ)
(not considered here for simplicity).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (153/199)

===== PAGE 230 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Capturing basic ontology constructs in DL-Lite A
ISA between classes A1⊑A2
Disjointness between classes A1⊑ ¬A2
Domain and range of properties ∃P⊑A1∃P−⊑A2
Mandatory participation (min card = 1) A1⊑ ∃P A 2⊑ ∃P−
Functionality of relations (max card = 1) (funct P) (funct P−)
ISA between properties Q1⊑Q2
Disjointness between properties Q1⊑ ¬Q2
Note 1: DL-Lite Acannot capture completeness of a hierarchy. This
would require disjunction (i.e., OR).
Note2: DL-Lite Acan be extended to capture also min cardinality
constraints (A⊑≤nQ) and max cardinality constraints (A⊑≥nQ)
(not considered here for simplicity).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (153/199)

===== PAGE 231 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example
empCode: Integersalary: IntegerEmployee   Manager
  AreaManager TopManager1..*1..1boss projectName: StringProject1..*1..11..1worksFormanages1..*
{disjoint}
Professor ⊑Faculty
AssocProf ⊑Professor
Dean ⊑Professor
AssocProf ⊑ ¬ Dean
Faculty ⊑ ∃ age
∃age−⊑xsd:integer
(funct age)
∃worksFor ⊑Faculty
∃worksFor−⊑College
Faculty ⊑ ∃ worksFor
College ⊑ ∃ worksFor−
∃isHeadOf ⊑Dean
∃isHeadOf−⊑College
Dean ⊑ ∃ isHeadOf
College ⊑ ∃ isHeadOf−
isHeadOf ⊑worksFor
(funct isHeadOf )
(funct isHeadOf−)
...M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (154/199)

===== PAGE 232 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Observations on DL-Lite A
Captures all the basic constructs of UML Class Diagrams and of
theER Model . . .
. . .except covering constraints in generalizations.
Is the logical underpinning of OWL2 QL , one of the OWL 2
Profiles.
Extends (the DL fragment of) the ontology language RDFS .
Is completely symmetric w.r.t. direct and inverse properties .
Does notenjoy the finite model property , i.e., reasoning and
query answering differ depending on whether we consider or not
also infinite models.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (155/199)

===== PAGE 233 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Observations on DL-Lite A
Captures all the basic constructs of UML Class Diagrams and of
theER Model . . .
. . .except covering constraints in generalizations.
Is the logical underpinning of OWL2 QL , one of the OWL 2
Profiles.
Extends (the DL fragment of) the ontology language RDFS .
Is completely symmetric w.r.t. direct and inverse properties .
Does notenjoy the finite model property , i.e., reasoning and
query answering differ depending on whether we consider or not
also infinite models.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (155/199)

===== PAGE 234 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A
We study answering of UCQs over DL-Lite Aontologies via query
rewriting.
We first consider query answering over satisfiable ontologies , i.e., that
admit at least one model.
Then, we show how to exploit query answering over satisfiable ontologies
to establish ontology satisfiability.
Remark
We call positive inclusions (PIs) assertions of the form
B1⊑B2
Q1⊑Q2
whereas we call negative inclusions (NIs) assertions of the form
B1⊑ ¬ B2
Q1⊑ ¬ Q2
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (156/199)

===== PAGE 235 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A
We study answering of UCQs over DL-Lite Aontologies via query
rewriting.
We first consider query answering over satisfiable ontologies , i.e., that
admit at least one model.
Then, we show how to exploit query answering over satisfiable ontologies
to establish ontology satisfiability.
Remark
We call positive inclusions (PIs) assertions of the form
B1⊑B2
Q1⊑Q2
whereas we call negative inclusions (NIs) assertions of the form
B1⊑ ¬ B2
Q1⊑ ¬ Q2
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (156/199)

===== PAGE 236 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering over satisfiable DL-Lite Aontologies
Theorem
Letqbe a boolean UCQs and T=TPI∪ TNI∪ Tfunct be a TBox s.t.
TPIis a set of PIs
TNIis a set of NIs
Tfunct is a set of functionalities.
For each ABox Asuch that ⟨T,A⟩is satisfiable , we have that
⟨T,A⟩ |=qiff⟨TPI,A⟩ |=q.
Proof [intuition]
qis a positive query, i.e., it does not contain atoms with negation nor
inequality. TNIandTfunct only contribute to infer new negative
consequences, i.e, sentences involving negation.
Ifqis non-boolean, we have that cert(q,⟨T,A⟩) =cert(q,⟨TPI,A⟩).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (157/199)

===== PAGE 237 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering over satisfiable DL-Lite Aontologies
Theorem
Letqbe a boolean UCQs and T=TPI∪ TNI∪ Tfunct be a TBox s.t.
TPIis a set of PIs
TNIis a set of NIs
Tfunct is a set of functionalities.
For each ABox Asuch that ⟨T,A⟩is satisfiable , we have that
⟨T,A⟩ |=qiff⟨TPI,A⟩ |=q.
Proof [intuition]
qis a positive query, i.e., it does not contain atoms with negation nor
inequality. TNIandTfunct only contribute to infer new negative
consequences, i.e, sentences involving negation.
Ifqis non-boolean, we have that cert(q,⟨T,A⟩) =cert(q,⟨TPI,A⟩).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (157/199)

===== PAGE 238 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering over satisfiable DL-Lite Aontologies
Theorem
Letqbe a boolean UCQs and T=TPI∪ TNI∪ Tfunct be a TBox s.t.
TPIis a set of PIs
TNIis a set of NIs
Tfunct is a set of functionalities.
For each ABox Asuch that ⟨T,A⟩is satisfiable , we have that
⟨T,A⟩ |=qiff⟨TPI,A⟩ |=q.
Proof [intuition]
qis a positive query, i.e., it does not contain atoms with negation nor
inequality. TNIandTfunct only contribute to infer new negative
consequences, i.e, sentences involving negation.
Ifqis non-boolean, we have that cert(q,⟨T,A⟩) =cert(q,⟨TPI,A⟩).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (157/199)

===== PAGE 239 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies
⟨T,∅⟩is always satisfiable. That is, inconsistency in DL-Lite Amay arise
only when ABox assertions contradict the TBox.
⟨TPI,A⟩, where TPIcontains only PIs, is always satisfiable. That is,
inconsistency in DL-Lite Amay arise only when ABox assertions violate
functionalities or NIs.
Example: TBox T:Professor ⊑ ¬Student
∃teaches ⊑Professor
(funct teaches−)
ABox A:teaches (John,databases )
Student (John)
teaches (Mark,databases )
Violations of functionalities and of NIs can be checked separately!
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (158/199)

===== PAGE 240 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies
⟨T,∅⟩is always satisfiable. That is, inconsistency in DL-Lite Amay arise
only when ABox assertions contradict the TBox.
⟨TPI,A⟩, where TPIcontains only PIs, is always satisfiable. That is,
inconsistency in DL-Lite Amay arise only when ABox assertions violate
functionalities or NIs.
Example: TBox T:Professor ⊑ ¬Student
∃teaches ⊑Professor
(funct teaches−)
ABox A:teaches (John,databases )
Student (John)
teaches (Mark,databases )
Violations of functionalities and of NIs can be checked separately!
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (158/199)

===== PAGE 241 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies
⟨T,∅⟩is always satisfiable. That is, inconsistency in DL-Lite Amay arise
only when ABox assertions contradict the TBox.
⟨TPI,A⟩, where TPIcontains only PIs, is always satisfiable. That is,
inconsistency in DL-Lite Amay arise only when ABox assertions violate
functionalities or NIs.
Example: TBox T:Professor ⊑ ¬Student
∃teaches ⊑Professor
(funct teaches−)
ABox A:teaches (John,databases )
Student (John)
teaches (Mark,databases )
Violations of functionalities and of NIs can be checked separately!
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (158/199)

===== PAGE 242 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies
⟨T,∅⟩is always satisfiable. That is, inconsistency in DL-Lite Amay arise
only when ABox assertions contradict the TBox.
⟨TPI,A⟩, where TPIcontains only PIs, is always satisfiable. That is,
inconsistency in DL-Lite Amay arise only when ABox assertions violate
functionalities or NIs.
Example: TBox T:Professor ⊑ ¬Student
∃teaches ⊑Professor
(funct teaches−)
ABox A:teaches (John,databases )
Student (John)
teaches (Mark,databases )
Violations of functionalities and of NIs can be checked separately!
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (158/199)

===== PAGE 243 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies: Checking functs
Theorem
LetTPIbe a TBox with only PIs, and (funct Q)a functionality
assertion. Then, for any ABox A,
⟨TPI∪{(funct Q)},A⟩is sat iff A ̸|=∃x, y, z .Q(x, y)∧Q(x, z)∧y̸=z.
Proof [sketch]
⟨TPI∪ {(funct Q)},A⟩is satisfiable iff ⟨TPI,A⟩ ̸|=¬(funct Q). This
holds iff A ̸|=¬(funct Q)(separability property – sophisticated proof).
From separability, the claim easily follows, by noticing that (funct Q)
corresponds to the FOL sentence ∀x, y, z .Q(x, y)∧Q(x, z)→y=z.
For a set of functionalities, we take the union of sentences of the form
above (which corresponds to a boolean FOL query).
Checking satisfiability wrt functionalities therefore amounts to evaluate
a FOL query over the ABox.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (159/199)

===== PAGE 244 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies: Checking functs
Theorem
LetTPIbe a TBox with only PIs, and (funct Q)a functionality
assertion. Then, for any ABox A,
⟨TPI∪{(funct Q)},A⟩is sat iff A ̸|=∃x, y, z .Q(x, y)∧Q(x, z)∧y̸=z.
Proof [sketch]
⟨TPI∪ {(funct Q)},A⟩is satisfiable iff ⟨TPI,A⟩ ̸|=¬(funct Q). This
holds iff A ̸|=¬(funct Q)(separability property – sophisticated proof).
From separability, the claim easily follows, by noticing that (funct Q)
corresponds to the FOL sentence ∀x, y, z .Q(x, y)∧Q(x, z)→y=z.
For a set of functionalities, we take the union of sentences of the form
above (which corresponds to a boolean FOL query).
Checking satisfiability wrt functionalities therefore amounts to evaluate
a FOL query over the ABox.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (159/199)

===== PAGE 245 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies: Checking functs
Theorem
LetTPIbe a TBox with only PIs, and (funct Q)a functionality
assertion. Then, for any ABox A,
⟨TPI∪{(funct Q)},A⟩is sat iff A ̸|=∃x, y, z .Q(x, y)∧Q(x, z)∧y̸=z.
Proof [sketch]
⟨TPI∪ {(funct Q)},A⟩is satisfiable iff ⟨TPI,A⟩ ̸|=¬(funct Q). This
holds iff A ̸|=¬(funct Q)(separability property – sophisticated proof).
From separability, the claim easily follows, by noticing that (funct Q)
corresponds to the FOL sentence ∀x, y, z .Q(x, y)∧Q(x, z)→y=z.
For a set of functionalities, we take the union of sentences of the form
above (which corresponds to a boolean FOL query).
Checking satisfiability wrt functionalities therefore amounts to evaluate
a FOL query over the ABox.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (159/199)

===== PAGE 246 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example
TBox T:Professor ⊑ ¬Student
∃teaches ⊑Professor
(funct teaches−)
The query we associate to the functionality is:
q()←teaches (x, y),teaches (x, z), y̸=z
which evaluated over the ABox
ABox A:teaches (John,databases )
Student (John)
teaches (Mark,databases )
returns true.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (160/199)

===== PAGE 247 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies: Checking NIs
Theorem
LetTPIbe a TBox with only PIs, and A1⊑ ¬A2a NI. For any ABox A,
⟨TPI∪ {A1⊑ ¬A2},A⟩is sat iff ⟨TPI,A⟩ ̸|=∃x.A1(x)∧A2(x).
Proof [sketch]
⟨TPI∪ {A1⊑ ¬A2},A⟩is satisfiable iff ⟨TPI,A⟩ ̸|=¬(A1⊑ ¬A2). The
claim follows easily by noticing that A1⊑ ¬A2corresponds to the FOL
sentence ∀x.A1(x)→ ¬A2(x).
The property holds for all kinds of NIs ( A⊑ ∃Q,∃Q1⊑ ∃Q2, etc.)
For a set of NIs, we take the union of sentences of the form above
(which corresponds to a UCQ).
Checking satisfiability wrt NIs amounts to answering a UCQ over an
ontology with only PIs (this can be reduced to evaluating a UCQ over
the ABox – see later).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (161/199)

===== PAGE 248 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies: Checking NIs
Theorem
LetTPIbe a TBox with only PIs, and A1⊑ ¬A2a NI. For any ABox A,
⟨TPI∪ {A1⊑ ¬A2},A⟩is sat iff ⟨TPI,A⟩ ̸|=∃x.A1(x)∧A2(x).
Proof [sketch]
⟨TPI∪ {A1⊑ ¬A2},A⟩is satisfiable iff ⟨TPI,A⟩ ̸|=¬(A1⊑ ¬A2). The
claim follows easily by noticing that A1⊑ ¬A2corresponds to the FOL
sentence ∀x.A1(x)→ ¬A2(x).
The property holds for all kinds of NIs ( A⊑ ∃Q,∃Q1⊑ ∃Q2, etc.)
For a set of NIs, we take the union of sentences of the form above
(which corresponds to a UCQ).
Checking satisfiability wrt NIs amounts to answering a UCQ over an
ontology with only PIs (this can be reduced to evaluating a UCQ over
the ABox – see later).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (161/199)

===== PAGE 249 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Satisfiability of DL-Lite Aontologies: Checking NIs
Theorem
LetTPIbe a TBox with only PIs, and A1⊑ ¬A2a NI. For any ABox A,
⟨TPI∪ {A1⊑ ¬A2},A⟩is sat iff ⟨TPI,A⟩ ̸|=∃x.A1(x)∧A2(x).
Proof [sketch]
⟨TPI∪ {A1⊑ ¬A2},A⟩is satisfiable iff ⟨TPI,A⟩ ̸|=¬(A1⊑ ¬A2). The
claim follows easily by noticing that A1⊑ ¬A2corresponds to the FOL
sentence ∀x.A1(x)→ ¬A2(x).
The property holds for all kinds of NIs ( A⊑ ∃Q,∃Q1⊑ ∃Q2, etc.)
For a set of NIs, we take the union of sentences of the form above
(which corresponds to a UCQ).
Checking satisfiability wrt NIs amounts to answering a UCQ over an
ontology with only PIs (this can be reduced to evaluating a UCQ over
the ABox – see later).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (161/199)

===== PAGE 250 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example
TBox T:Professor ⊑ ¬Student
∃teaches ⊑Professor
(funct teaches−)
The query we associate to the NI is:
q()←Student (x),Professor (x)
whose answer over the ontology
∃teaches ⊑Professor
teaches (John,databases )
Student (John)
teaches (Mark,databases )
is true.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (162/199)

===== PAGE 251 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Checking satisfiability of DL-Lite Aontologies
Satisfiability of a DL-Lite Aontology O=⟨T,A⟩is reduced to
evaluation of a first order query over A, obtained by uniting
(a)the FOL query associated to functionalities in Tto
(b)the UCQs produced by a rewriting procedure (depending only on
the PIs in T) applied to the query associated to NIs in T.
;Ontology satisfiability in DL-Lite Acan be done using RDMBS
technology.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (163/199)

===== PAGE 252 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting
To the aim of answering queries, from now on we assume that T
contains only PIs.
Given a CQ qand a satisfiable ontology O=⟨T,A⟩, we compute
cert(q,O)as follows
1usingT,reformulate qas aunion rq,Tof CQs .
2Evaluate rq,Tdirectly over Amanaged in secondary storage via a
RDBMS .
Correctness of this procedure shows FOL-rewritability of query
answering in DL-Lite A
;Query answering over DL-Lite Aontologies can be done using
RDMBS technology.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (164/199)

===== PAGE 253 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting
To the aim of answering queries, from now on we assume that T
contains only PIs.
Given a CQ qand a satisfiable ontology O=⟨T,A⟩, we compute
cert(q,O)as follows
1usingT,reformulate qas aunion rq,Tof CQs .
2Evaluate rq,Tdirectly over Amanaged in secondary storage via a
RDBMS .
Correctness of this procedure shows FOL-rewritability of query
answering in DL-Lite A
;Query answering over DL-Lite Aontologies can be done using
RDMBS technology.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (164/199)

===== PAGE 254 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
Intuition: Use the PIs as basic rewriting rules
q(x)←Professor (x)
AssProfessor ⊑Professor
as a logic rule: Professor (z)←AssProfessor (z)
Basic rewriting step:
when the atom unifies with the head of the rule (with mgu σ).
substitute the atom with the body of the rule (to which σis applied).
Towards the computation of the perfect rewriting, we add to the input
query above the following query ( σ={z/x})
q(x)←AssProfessor (x)
We say that the PI AssProfessor ⊑Professor applies to the atom
Professor (x).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (165/199)

===== PAGE 255 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
Intuition: Use the PIs as basic rewriting rules
q(x)←Professor (x)
AssProfessor ⊑Professor
as a logic rule: Professor (z)←AssProfessor (z)
Basic rewriting step:
when the atom unifies with the head of the rule (with mgu σ).
substitute the atom with the body of the rule (to which σis applied).
Towards the computation of the perfect rewriting, we add to the input
query above the following query ( σ={z/x})
q(x)←AssProfessor (x)
We say that the PI AssProfessor ⊑Professor applies to the atom
Professor (x).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (165/199)

===== PAGE 256 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
Intuition: Use the PIs as basic rewriting rules
q(x)←Professor (x)
AssProfessor ⊑Professor
as a logic rule: Professor (z)←AssProfessor (z)
Basic rewriting step:
when the atom unifies with the head of the rule (with mgu σ).
substitute the atom with the body of the rule (to which σis applied).
Towards the computation of the perfect rewriting, we add to the input
query above the following query ( σ={z/x})
q(x)←AssProfessor (x)
We say that the PI AssProfessor ⊑Professor applies to the atom
Professor (x).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (165/199)

===== PAGE 257 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
Consider now the query
q(x)←teaches (x, y)
Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
We add to the reformulation the query ( σ={z1/x, z 2/y})
q(x)←Professor (x)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (166/199)

===== PAGE 258 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
Conversely, for the query
q(x)←teaches (x,databases )
Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
teaches (x,databases )does not unify with teaches (z1, z2), since the
existentially quantified variable z2in the head of the rule does not
unify with the constant databases .
In this case the PI does not apply to the atom teaches (x,databases ).
The same holds for the following query, where yisdistinguished
q(x, y)←teaches (x, y)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (167/199)

===== PAGE 259 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
Conversely, for the query
q(x)←teaches (x,databases )
Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
teaches (x,databases )does not unify with teaches (z1, z2), since the
existentially quantified variable z2in the head of the rule does not
unify with the constant databases .
In this case the PI does not apply to the atom teaches (x,databases ).
The same holds for the following query, where yisdistinguished
q(x, y)←teaches (x, y)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (167/199)

===== PAGE 260 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
Conversely, for the query
q(x)←teaches (x,databases )
Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
teaches (x,databases )does not unify with teaches (z1, z2), since the
existentially quantified variable z2in the head of the rule does not
unify with the constant databases .
In this case the PI does not apply to the atom teaches (x,databases ).
The same holds for the following query, where yisdistinguished
q(x, y)←teaches (x, y)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (167/199)

===== PAGE 261 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
An analogous behavior with join variables
q(x)←teaches (x, y),Course (y)
Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
The PI above does not apply to the atom teaches (x, y).
Conversely, the PI
∃teaches−⊑Course
as a logic rule: Course (z2)←teaches (z1, z2)
applies to the atom Course (y).
We add to the perfect rewriting the query ( σ={z2/y})
q(x)←teaches (x, y),teaches (z1, y)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (168/199)

===== PAGE 262 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
An analogous behavior with join variables
q(x)←teaches (x, y),Course (y)
Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
The PI above does not apply to the atom teaches (x, y).
Conversely, the PI
∃teaches−⊑Course
as a logic rule: Course (z2)←teaches (z1, z2)
applies to the atom Course (y).
We add to the perfect rewriting the query ( σ={z2/y})
q(x)←teaches (x, y),teaches (z1, y)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (168/199)

===== PAGE 263 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
We now have the query
q(x)←teaches (x, y),teaches (z, y)
The PI Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
does not apply to teaches (x, y)nor teaches (z, y), since yis a join
variable.
However, we can transform the above query by unifying the atoms
teaches (x, y), teaches (z1, y). This rewriting step is called reduce , and
produces the following query
q(x)←teaches (x, y)
We can now apply the PI above ( σ{z1/x, z 2/y}), and add to the
reformulation the query
q(x)←Professor (x)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (169/199)

===== PAGE 264 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Query rewriting (cont’d)
We now have the query
q(x)←teaches (x, y),teaches (z, y)
The PI Professor ⊑ ∃teaches
as a logic rule: teaches (z1, z2)←Professor (z1)
does not apply to teaches (x, y)nor teaches (z, y), since yis a join
variable.
However, we can transform the above query by unifying the atoms
teaches (x, y), teaches (z1, y). This rewriting step is called reduce , and
produces the following query
q(x)←teaches (x, y)
We can now apply the PI above ( σ{z1/x, z 2/y}), and add to the
reformulation the query
q(x)←Professor (x)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (169/199)

===== PAGE 265 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Answering by rewriting in DL-Lite A: The algorithm
1Rewrite the CQ qinto a UCQs: apply to qin all possible ways the
PIs in the TBox T.
2This corresponds to exploiting ISAs, role typings, and mandatory
participations to obtain new queries that could contribute to the
answer.
3Unifying atoms can make applicable rules that could not be applied
otherwise.
4The UCQs resulting from this process is the perfect rewriting rq,T.
5rq,Tis then encoded into SQL and evaluated over Amanaged in
secondary storage via a RDBMS , to return the set cert(q,O).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (170/199)

===== PAGE 266 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Query answering in DL-Lite A: Example
TBox: Professor ⊑ ∃teaches
∃teaches−⊑Course
Query: q(x)←teaches (x, y),Course (y)
Perfect Rewriting: q(x)←teaches (x, y),Course (y)
q(x)←teaches (x, y),teaches (z, y)
q(x)←teaches (x, z)
q(x)←Professor (x)
ABox: teaches (John,databases )
Professor (Mary)
It is easy to see that the evaluation of rq,ToverAin this case produces
the set {John,Mary}.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (171/199)

===== PAGE 267 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 1
Express in DL-Lite Athe following ontology:
CBD{subset}<R 
Q> 1..1{disjoint,complete}1..*A
Considering the following ABox A={A(a)}compute the answer to the
following queries:
q(x)←Q(x, y), R(y, z).
q′()←B(x).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (172/199)

===== PAGE 268 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 1 (solution)
Expansions:
q(x)←Q(x, y), R(y, z).
q(x)←Q(x, y), Q(z, y). Q ⊑R−
q(x)←Q(x, y). unify: z=x
q(x)←A(x). A ⊑ ∃Q
=⇒answer x=a
q′()←B(x).
q′()←R(x, y). ∃R.⊑B
q′()←A(y). A ⊑ ∃R−
=⇒answer true (byy=a)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (173/199)

===== PAGE 269 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 1 (solution)
Expansions:
q(x)←Q(x, y), R(y, z).
q(x)←Q(x, y), Q(z, y). Q ⊑R−
q(x)←Q(x, y). unify: z=x
q(x)←A(x). A ⊑ ∃Q
=⇒answer x=a
q′()←B(x).
q′()←R(x, y). ∃R.⊑B
q′()←A(y). A ⊑ ∃R−
=⇒answer true (byy=a)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (173/199)

===== PAGE 270 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 2
Express in DL-Lite Athe following ontology:
ACBD{subset}R >Q >1..1{disjoint,complete}0..*0..*0..*
Considering the following ABox A={Q(a, b), R(b, b), C(c)}compute
the answer to the following queries:
q(x)←R(x, y), R(y, z), A(z).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (174/199)

===== PAGE 271 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 2 (solution)
Expansions:
q(x) :- R(x,y), R(y,z), A(z).
q(x) :- R(x,x), A(x). --- unify
q(x) :- R(x,x), R(x,y). --- Exists R ISA A
q(x) :- R(x,x). --- unify
answer x = b
......
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (175/199)

===== PAGE 272 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 2 (solution)
Expansions:
.....
q(x) :- R(x,y), R(y,z), A(z).
q(x) :- R(x,y), R(y,z), C(z). --- C ISA A
q(x) :- R(x,y), R(y,z), Q(w,z). --- Exists Q- ISA C
q(x) :- R(x,y), Q(y,z), Q(w,z). --- Q ISA R
q(x) :- R(x,y), Q(y,z). --- unify
q(x) :- R(x,y), A(y). --- A ISA Exists Q
q(x) :- R(x,y), C(y). --- C ISA A
q(x) :- R(x,y), Q(z,y). --- Exists Q- ISA C
q(x) :- Q(x,y), Q(z,y). --- Q ISA R
q(x) :- Q(x,y). --- unify
answer x = a
q(x) :- A(x). --- A ISA Exists Q
q(x) :- C(x). --- C ISA A
answer x = cM. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (176/199)

===== PAGE 273 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 3
Express in DL-Lite Athe following ontology:
ADBE{subset}R >Q >1..1{disjoint,complete}0..*1..*1..*C
Considering the following ABox A={C(a)}compute the answer to the
following queries:
q(x)←R(x, y), B(y).
q′(x)←A(x).
Can we simplify the diagram?M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (177/199)

===== PAGE 274 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 3 (solution)
Expansions:
q(x) :- R(x,y), B(y).
q(x) :- R(x,y), D(y). --- D ISA B
q(x) :- R(x,y), Q(z,y). --- Exists Q- ISA D
q(x) :- Q(x,y), Q(z,y). --- Q ISA R
q(x) :- Q(x,y). --- unify
q(x) :- C(x). --- C ISA Exists Q
answer x = a
q’(x):- A(x).
q’(x):- R(x,y). --- A ISA Exists R
q’(x):- Q(x,y). --- Q ISA R
q’(x):- C(x). --- C ISA Exists Q
answer x = a
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (178/199)

===== PAGE 275 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 4
Express in DL-Lite Athe following ontology:
BAC{subset}<R 
<Q 1..1{disjoint,complete}1..*
Considering the following ABox A={B(b)}compute the answer to the
following queries:
q(z)←R(x, y), R(y, z).
q′()←C(x).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (179/199)

===== PAGE 276 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Example 4 (solution)
Expansions:
q(z) :- R(x,y), R(y,z).
q(z) :- A(y), R(y,z). --- A ISA Exists R-
q(z) :- A(y), Q(y,z). --- Q ISA R
q(z) :- C(y), Q(y,z). --- C ISA A
q(z) :- Q(y,w), Q(y,z). --- Exists Q ISA C
q(z) :- Q(y,z). --- unify
q(z) :- B(z). --- B ISA Exists Q-
answer z = b
q’() :- C(x).
q’() :- R(x,y). -- Exists R ISA C
q’() :- A(y). -- A ISA Exists R-
q’() :- B(y). -- B ISA A
answer z = b
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (180/199)

===== PAGE 277 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Complexity of reasoning in DL-Lite A
Ontology satisfiability and all classical DL reasoning tasks are:
Efficiently tractable in the size of TBox (i.e., PTime ).
Very efficiently tractable in the size of the ABox (i.e., LogSpace ).
In fact, reasoning can be done by constructing suitable FOL/SQL
queries and evaluating them over the ABox ( FOL-rewritability ).
Query answering for CQs and UCQs is:
PTime in the size of TBox.
LogSpace in the size of the ABox.
Exponential in the size of the query ( NP-complete).
Bad? . . . not really, this is exactly as in relational DBs.
Can we go beyond DL-Lite A?
By adding essentially any other DL construct, e.g., union ( ⊔), value
restriction ( ∀R.C), etc., without some limitations we lose these nice
computational properties (see later).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (181/199)

===== PAGE 278 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Complexity of reasoning in DL-Lite A
Ontology satisfiability and all classical DL reasoning tasks are:
Efficiently tractable in the size of TBox (i.e., PTime ).
Very efficiently tractable in the size of the ABox (i.e., LogSpace ).
In fact, reasoning can be done by constructing suitable FOL/SQL
queries and evaluating them over the ABox ( FOL-rewritability ).
Query answering for CQs and UCQs is:
PTime in the size of TBox.
LogSpace in the size of the ABox.
Exponential in the size of the query ( NP-complete).
Bad? . . . not really, this is exactly as in relational DBs.
Can we go beyond DL-Lite A?
By adding essentially any other DL construct, e.g., union ( ⊔), value
restriction ( ∀R.C), etc., without some limitations we lose these nice
computational properties (see later).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (181/199)

===== PAGE 279 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Complexity of reasoning in DL-Lite A
Ontology satisfiability and all classical DL reasoning tasks are:
Efficiently tractable in the size of TBox (i.e., PTime ).
Very efficiently tractable in the size of the ABox (i.e., LogSpace ).
In fact, reasoning can be done by constructing suitable FOL/SQL
queries and evaluating them over the ABox ( FOL-rewritability ).
Query answering for CQs and UCQs is:
PTime in the size of TBox.
LogSpace in the size of the ABox.
Exponential in the size of the query ( NP-complete).
Bad? . . . not really, this is exactly as in relational DBs.
Can we go beyond DL-Lite A?
By adding essentially any other DL construct, e.g., union ( ⊔), value
restriction ( ∀R.C), etc., without some limitations we lose these nice
computational properties (see later).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (181/199)

===== PAGE 280 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Complexity of reasoning in DL-Lite A
Ontology satisfiability and all classical DL reasoning tasks are:
Efficiently tractable in the size of TBox (i.e., PTime ).
Very efficiently tractable in the size of the ABox (i.e., LogSpace ).
In fact, reasoning can be done by constructing suitable FOL/SQL
queries and evaluating them over the ABox ( FOL-rewritability ).
Query answering for CQs and UCQs is:
PTime in the size of TBox.
LogSpace in the size of the ABox.
Exponential in the size of the query ( NP-complete).
Bad? . . . not really, this is exactly as in relational DBs.
Can we go beyond DL-Lite A?
By adding essentially any other DL construct, e.g., union ( ⊔), value
restriction ( ∀R.C), etc., without some limitations we lose these nice
computational properties (see later).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (181/199)

===== PAGE 281 =====

Ontologies Ontology-based data integration in DL-Lite
The DL-Lite family Part 3: Ontology based data integration
Beyond DL-Lite A: results on data complexity
lhs rhs funct.Prop.
incl.Data complexity
of query answering
0 DL-Lite A√*√* inLogSpace
1 A| ∃P.A A − − NLogSpace -hard
2 A A| ∀P.A − − NLogSpace -hard
3 A A| ∃P.A√− NLogSpace -hard
4A| ∃P.A|A1⊓A2 A − − PTime -hard
5 A|A1⊓A2 A| ∀P.A − − PTime -hard
6 A|A1⊓A2 A| ∃P.A√− PTime -hard
7A| ∃P.A| ∃P−.A A| ∃P − − PTime -hard
8 A| ∃P| ∃P−A| ∃P| ∃P− √ √PTime -hard
9 A| ¬A A − − coNP-hard
10 A A|A1⊔A2 − − coNP-hard
11 A| ∀P.A A − − coNP-hard
* with the “proviso” of not specializing functional properties.
NLogSpace andPTime hardness holds already for instance checking.
ForcoNP -hardness in line 10, a TBox with a single assertion
AL⊑AT⊔AFsuffices!;Nohope of including covering constraints .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (182/199)

===== PAGE 282 =====

Ontologies Ontology-based data integration in DL-Lite
Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
6Ontology-based data integration in DL-Lite
Overview
Query answering
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (183/199)

===== PAGE 283 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
6Ontology-based data integration in DL-Lite
Overview
Query answering
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (184/199)

===== PAGE 284 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Ontology-based data integration: the DL-Lite solution
ontology-based data integration
sourcesq
sources
sources
ontology
We require the data sources to be wrapped and presented as relational
sources.;“standard technology”
We make use of a data federation tool , such as IBM Information
Integrator, to present the yet to be (semantically) integrated sources as a
single relational database. ;“standard technology”
We make use of the DL-Lite technology presented above for the
conceptual view on the data, to exploit effectiveness of query
answering .;“new technology”
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (185/199)

===== PAGE 285 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Ontology-based data integration: the DL-Lite solution
ontology-based data integration
sourcesq
sources
sources
ontology
The (federated) source database is external andindependent from the
conceptual view (the ontology).
Mappings relate information in the sources to the ontology. ;sort of
virtual ABox
We use GAV (global-as-view) mappings: the result of an (arbitrary) SQL
query on the source database is considered a (partial) extension of a
concept/role.
Moreover, we properly deal with the notorious impedance mismatch
problem !
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (186/199)

===== PAGE 286 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Impedance mismatch problem
The impedance mismatch problem
Inrelational databases , information is represented in forms of
tuples of values .
Inontologies (or more generally object-oriented systems or
conceptual models), information is represented using both objects
and values ...
... with objects playing the main role, ...
... and values a subsidiary role as fillers of object’s attributes.
;How do we reconcile these views?
Solution: We need constructors to create objects of the ontology out
of tuples of values in the database.
Note: from a formal point of view, such constructors can be simply
Skolem functions!
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (187/199)

===== PAGE 287 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Impedance mismatch – Example
empCode: Integersalary: IntegerEmployee  projectName: StringProject1..*worksFor1..*
Actual data is stored in a DB:
D1[SSN:String ,PrName :String ]
Employees and Projects they work for
D2[Code :String ,Salary :Int]
Employee’s Code with salary
D3[Code :String ,SSN:String ]
Employee’s Code with SSN
. . .
From the domain analysis it turns out that:
An employee should be created from her SSN:pers(SSN)
A project should be created from its Name :proj(PrName )
pers andproj are Skolem functions.
If VRD56B25 is a SSN, then pers(VRD56B25) is an object term denoting a
person.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (188/199)

===== PAGE 288 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Impedance mismatch – Example
empCode: Integersalary: IntegerEmployee  projectName: StringProject1..*worksFor1..*
Actual data is stored in a DB:
D1[SSN:String ,PrName :String ]
Employees and Projects they work for
D2[Code :String ,Salary :Int]
Employee’s Code with salary
D3[Code :String ,SSN:String ]
Employee’s Code with SSN
. . .
From the domain analysis it turns out that:
An employee should be created from her SSN:pers(SSN)
A project should be created from its Name :proj(PrName )
pers andproj are Skolem functions.
If VRD56B25 is a SSN, then pers(VRD56B25) is an object term denoting a
person.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (188/199)

===== PAGE 289 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Impedance mismatch: the technical solution
Creating object identifiers
LetΓVbe the alphabet of constants (values) appearing in the
sources.
We introduce an alphabet Λoffunction symbols , each with an
associated arity, specifying the number of arguments it accepts.
To denote objects, i.e., instances of concepts in the ontology, we
useobject terms of the form f(d1, . . . , d n), with f∈Λof arity n,
and each dia value constant in ΓV.
;No confusion between the values stored in the database and the
terms denoting objects.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (189/199)

===== PAGE 290 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Formalization of ontology with mappings to data sources
Anontology with mappings is characterized by a triple
Om=⟨T,S,M⟩such that:
Tis a TBox;
Sis a (federated) relational database representing the sources;
Mis a set of mapping assertions , each one of the form∗
Φ(⃗ x);Ψ(f(⃗ x), ⃗ x)
where
Φ(⃗ x)is an arbitrary SQL query over S, returning attributes ⃗ x
Ψ(f(⃗ x), ⃗ x)is (the body of) a conjunctive query over Twithout
non-distinguished variables , whose variables, possibly occurring in
terms, i.e., f(⃗ x), are from ⃗ x.
∗Note: this is a form of GAV mapping
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (190/199)

===== PAGE 291 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Ontology with mappings – Example
TBoxT(UML)
empCode: Integersalary: IntegerEmployee  projectName: StringProject1..*worksFor1..* federated schema of the DB S
D1[SSN:String ,PrName :String ]
Employees and Projects they work for
D2[Code :String ,Salary :Int]
Employee’s Code with salary
D3[Code :String ,SSN:String ]
Employee’s Code with SSN
. . .
Mapping M
M1:SELECT SSN, PrName
FROM D 1;Employee( pers(SSN)),
Project( proj(PrName )),
projectName( proj(PrName ),PrName ),
workFor( pers(SSN),proj(PrName ))
M2:SELECT SSN, Salary
FROM D 2, D 3
WHERE D 2.Code = D 3.Code;Employee( pers(SSN)),
salary( pers(SSN),Salary )
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (191/199)

===== PAGE 292 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Semantics
Def.: Semantics of mappings
We say that I= (∆I,·I)satisfies Φ(⃗ x);Ψ(f(⃗ x), ⃗ x)wrt a database S, if for
every tuple of values ⃗ vin the answer of the SQL query Φ(⃗ x)overS, and for
each ground atom XinΨ(f(⃗ v),⃗ v), we have that:
ifXhas the form A(s), then sI∈AI;
ifXhas the form P(s1, s2), then (sI
1, sI
2)∈PI.
Def.: Semantics of ontologies with mappings
Iis amodel ofOm=⟨T,S,M⟩if:
Iis a model of T;
Isatisfies MwrtS, i.e., satisfies every assertion in MwrtS.
Def.: The certain answers toq(⃗ x)overOm=⟨T,S,M⟩. . .
. . . denoted cert(q,Om), are the tuples ⃗ cof constants of Ssuch that
⃗ c∈qI, for every model IofOm.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (192/199)

===== PAGE 293 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Semantics
Def.: Semantics of mappings
We say that I= (∆I,·I)satisfies Φ(⃗ x);Ψ(f(⃗ x), ⃗ x)wrt a database S, if for
every tuple of values ⃗ vin the answer of the SQL query Φ(⃗ x)overS, and for
each ground atom XinΨ(f(⃗ v),⃗ v), we have that:
ifXhas the form A(s), then sI∈AI;
ifXhas the form P(s1, s2), then (sI
1, sI
2)∈PI.
Def.: Semantics of ontologies with mappings
Iis amodel ofOm=⟨T,S,M⟩if:
Iis a model of T;
Isatisfies MwrtS, i.e., satisfies every assertion in MwrtS.
Def.: The certain answers toq(⃗ x)overOm=⟨T,S,M⟩. . .
. . . denoted cert(q,Om), are the tuples ⃗ cof constants of Ssuch that
⃗ c∈qI, for every model IofOm.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (192/199)

===== PAGE 294 =====

Ontologies Ontology-based data integration in DL-Lite
Overview Part 3: Ontology based data integration
Semantics
Def.: Semantics of mappings
We say that I= (∆I,·I)satisfies Φ(⃗ x);Ψ(f(⃗ x), ⃗ x)wrt a database S, if for
every tuple of values ⃗ vin the answer of the SQL query Φ(⃗ x)overS, and for
each ground atom XinΨ(f(⃗ v),⃗ v), we have that:
ifXhas the form A(s), then sI∈AI;
ifXhas the form P(s1, s2), then (sI
1, sI
2)∈PI.
Def.: Semantics of ontologies with mappings
Iis amodel ofOm=⟨T,S,M⟩if:
Iis a model of T;
Isatisfies MwrtS, i.e., satisfies every assertion in MwrtS.
Def.: The certain answers toq(⃗ x)overOm=⟨T,S,M⟩. . .
. . . denoted cert(q,Om), are the tuples ⃗ cof constants of Ssuch that
⃗ c∈qI, for every model IofOm.
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (192/199)

===== PAGE 295 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Outline of Part 3
5Ontologies
6Ontology-based data integration in DL-Lite
Overview
Query answering
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (193/199)

===== PAGE 296 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
DL-Lite Aquery answering for data integration
Given a (U)CQ qandOm=⟨T,S,M⟩(assumed satisfiable, i.e., there
exists at least one model for Om), we compute cert(q,Om)as follows:
1Using T,reformulate CQqas a union rq,Tof CQs.
2Using M,unfold rq,Tto obtain a union unfold (rq,T)of CQs.
3Evaluate unfold (rq,T)directly over Susing RDBMS technology.
Correctness of this algorithm shows FOL-reducibility of query answering.
;Query answering can again be done using RDBMS technology .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (194/199)

===== PAGE 297 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Example – query rewriting
TBoxT(UML)
empCode: Integersalary: IntegerEmployee  projectName: StringProject1..*worksFor1..*
TBoxT(DL-Lite A)
Employee ⊑ ∃ worksFor
∃worksFor ⊑Employee
∃worksFor−⊑Project
Project ⊑ ∃ worksFor−
...
Consider the query q(x)←worksFor (x, y)
the perfect rewriting is
rq,T=q(x)←worksFor (x, y)
q(x)←Employee (x)
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (195/199)

===== PAGE 298 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Example – splitting the mapping
To compute unfold (rq,T), we first splitMas follows (always possible, since queries
in the right-hand side of assertions in Mare without non-distinguished variables):
M1,1:SELECT SSN, PrName
FROM D 1;Employee( pers(SSN))
M1,2:SELECT SSN, PrName
FROM D 1;Project( proj(PrName ))
M1,3:SELECT SSN, PrName
FROM D 1;projectName( proj(PrName ),PrName )
M1,4:SELECT SSN, PrName
FROM D 1;workFor( pers(SSN),proj(PrName ))
M2,1:SELECT SSN, Salary
FROM D 2, D 3
WHERE D 2.Code = D 3.Code;Employee( pers(SSN))
M2,2:SELECT SSN, Salary
FROM D 2, D 3
WHERE D 2.Code = D 3.Code;salary( pers(SSN),Salary )
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (196/199)

===== PAGE 299 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Example – unfolding
Then, we unify each atom of the query
rq,T=q(x)← worksFor (x, y)
q(x)← Employee (x)
with the right-hand side of the assertion in the split mapping, and substitute
such atom with the left-hand side of the mapping
q(pers(SSN))← SELECT SSN, PrName
FROM D 1
q(pers(SSN))← SELECT SSN, Salary
FROM D 2, D 3
WHERE D 2.CODE = D 3.CODE
The construction of object terms can be pushed into the SQL query, by
resorting to SQL functions to manipulate strings (e.g., string concat).
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (197/199)

===== PAGE 300 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Example – SQL query over the source database
SELECT concat(concat(’pers (’,SSN),’)’)
FROM D 1
UNION
SELECT concat(concat(’pers (’,SSN),’)’)
FROM D 2, D3
WHERE D 2.Code = D 3.Code
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (198/199)

===== PAGE 301 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Computational complexity of query answering
Theorem
Query answering in aDL-Lite Aontology with mappings
O=⟨T,S,M⟩is
1NP-complete in the size of the query.
2PTime in the size of the TBox Tand the mappings M.
3LogSpace in the size of the database S, in fact FOL-rewritable.
Can we move to LAV or GLAV mappings?
No, if we want to have DL-Lite ATBoxes and stay in LogSpace !
Alternatively, we can have LAV or GLAV mappings, but we have to
renounce to use functionalities in the TBox (thus not having
DL-Lite ATBoxes) and limit the form of the queries in the mapping
(essentially CQs over both the sources and the ontology), if we want to
stay in LogSpace .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (199/199)

===== PAGE 302 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Computational complexity of query answering
Theorem
Query answering in aDL-Lite Aontology with mappings
O=⟨T,S,M⟩is
1NP-complete in the size of the query.
2PTime in the size of the TBox Tand the mappings M.
3LogSpace in the size of the database S, in fact FOL-rewritable.
Can we move to LAV or GLAV mappings?
No, if we want to have DL-Lite ATBoxes and stay in LogSpace !
Alternatively, we can have LAV or GLAV mappings, but we have to
renounce to use functionalities in the TBox (thus not having
DL-Lite ATBoxes) and limit the form of the queries in the mapping
(essentially CQs over both the sources and the ontology), if we want to
stay in LogSpace .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (199/199)

===== PAGE 303 =====

Ontologies Ontology-based data integration in DL-Lite
Query answering Part 3: Ontology based data integration
Computational complexity of query answering
Theorem
Query answering in aDL-Lite Aontology with mappings
O=⟨T,S,M⟩is
1NP-complete in the size of the query.
2PTime in the size of the TBox Tand the mappings M.
3LogSpace in the size of the database S, in fact FOL-rewritable.
Can we move to LAV or GLAV mappings?
No, if we want to have DL-Lite ATBoxes and stay in LogSpace !
Alternatively, we can have LAV or GLAV mappings, but we have to
renounce to use functionalities in the TBox (thus not having
DL-Lite ATBoxes) and limit the form of the queries in the mapping
(essentially CQs over both the sources and the ontology), if we want to
stay in LogSpace .
M. Lenzerini - A. Poggi Theory of Information Integration LSDM 2024/2025 (199/199)