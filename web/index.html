<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NBA Search</title>
    <link rel="stylesheet" href="/static/app.css" />
  </head>
  <body>
    <div class="topbar">
      <div class="inner">
        <div class="brand">NBA Search</div>
        <div class="nav">
          <a href="/">Search</a>
          <a href="/predict-ui">Predict</a>
        </div>
      </div>
    </div>
    <div class="wrap">
      <h1 class="fade-in">Search (players • teams • games)</h1>
      <form id="f" class="search-box" autocomplete="off">
        <input id="q" class="input" type="text" placeholder="e.g. Michael Jordan, Lakers 2010, 2016-06-19" autocomplete="off" aria-autocomplete="list" />
        <button id="btn" class="btn" type="submit">Search</button>
        <div id="sugg" class="suggest" style="display:none"></div>
      </form>
      <div class="meta" id="meta"></div>
      <div class="error" id="err"></div>
      <div class="results" id="results"></div>
      <div id="detail" class="card" style="display:none; position: fixed; right: 20px; bottom: 20px; max-width: 420px; z-index: 10;"></div>
      <footer style="margin: 28px 0; color: var(--muted); font-size: 12px;">
        Minimal UI. Results powered by the local FastAPI service.
      </footer>
    </div>
    <script src="/static/app.js"></script>
    <script>
      const f = document.getElementById('f');
      const q = document.getElementById('q');
      const btn = document.getElementById('btn');
      const meta = document.getElementById('meta');
      const err = document.getElementById('err');
      const results = document.getElementById('results');
      const sugg = document.getElementById('sugg');
      // stable suggest state (keeps last good results across small typos)
      let lastGoodQuery = '';
      let lastGoodItems = [];
      let activeSuggestReq = 0;

      function openEntity(it) {
        if (!it || !it._entity || !it._id) return;
        let path = "/";
        if (it._entity === "player") path = `/player/${encodeURIComponent(it._id)}`;
        else if (it._entity === "team") path = `/team/${encodeURIComponent(it._id)}`;
        else if (it._entity === "game") path = `/game/${encodeURIComponent(it._id)}`;
        else if (it._entity === "matchup") {
          const parts = String(it._id).split('-');
          if (parts.length === 2) path = `/matchup/${encodeURIComponent(parts[0])}/${encodeURIComponent(parts[1])}`;
        }
        window.location.href = path;
      }
      function renderItems(items) {
        results.innerHTML = '';
        if (!items || items.length === 0) {
          results.innerHTML = '<div class="sub">No results.</div>';
          return;
        }
        for (const it of items) {
          const div = document.createElement('div');
          div.className = 'card slide-up';
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = it._entity || '-';
          const box = document.createElement('div');
          const title = document.createElement('div');
          title.className = 'title';
          title.innerHTML = highlight(it._title || it._id, q.value);
          const sub = document.createElement('div');
          sub.className = 'sub';
          sub.innerHTML = highlight(it._subtitle || '', q.value);
          const extra = document.createElement('div');
          extra.className = 'extra';
          extra.textContent = it._extra || '';
          box.appendChild(title);
          if (sub.textContent) box.appendChild(sub);
          if (extra.textContent) box.appendChild(extra);
          div.appendChild(badge);
          div.appendChild(box);
          // click to open details
          div.style.cursor = 'pointer';
          div.addEventListener('click', () => openEntity(it));
          results.appendChild(div);
        }
      }

      async function doSearch(text) {
        err.textContent = '';
        setLoading(meta, true);
        results.innerHTML = Array.from({length: 5}).map(()=>'<div class="card"><div class="skeleton" style="width:76px;height:22px;border-radius:6px"></div><div style="flex:1"><div class="skeleton" style="height:14px;margin-bottom:8px"></div><div class="skeleton" style="height:12px;width:60%"></div></div></div>').join('');
        btn.disabled = true;
        try {
          const url = `/search?q=${encodeURIComponent(text)}&limit=50`;
          const res = await fetch(url, { headers: { 'accept': 'application/json' } });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          meta.textContent = `Query: ${data?.meta?.query || text}  •  Results: ${data?.total ?? data?.items?.length ?? 0}`;
          renderItems(data.items || []);
        } catch (e) {
          console.error(e);
          err.textContent = `Error: ${e.message || e}`;
          meta.textContent = '';
        } finally {
          btn.disabled = false;
          setLoading(meta, false);
        }
      }

      function renderSuggest(items) {
        if (!items || items.length === 0) { sugg.style.display = 'none'; sugg.innerHTML = ''; return; }
        sugg.innerHTML = '';
        items.slice(0, 12).forEach((it, idx) => {
          const div = document.createElement('div');
          div.className = 's-item' + (idx === 0 ? ' active' : '');
          div.dataset.idx = idx;
          const badge = document.createElement('div');
          badge.className = 's-entity'; badge.textContent = it._entity || '-';
          const box = document.createElement('div');
          const t = document.createElement('div'); t.className = 's-title'; t.innerHTML = highlight(it._title || it._id || '', q.value);
          const s = document.createElement('div'); s.className = 's-sub'; s.innerHTML = highlight(it._subtitle || '', q.value);
          box.appendChild(t); if (s.textContent) box.appendChild(s);
          div.appendChild(badge); div.appendChild(box);
          div.addEventListener('mousedown', (ev) => {
            ev.preventDefault();
            q.value = (it._title || it._id || '').toString();
            sugg.style.display='none';
            if (it && it._entity && it._id) {
              openEntity(it);
            } else {
              doSearch(q.value);
            }
          });
          sugg.appendChild(div);
        });
        sugg.style.display = 'block';
      }

      // Instant suggest with small debounce refresh + stability on typos
      let suggestTimer = null;
      q.addEventListener('input', () => {
        const text = (q.value || '').trim();
        if (!text) {
          if (suggestTimer) clearTimeout(suggestTimer);
          sugg.style.display = 'none';
          sugg.innerHTML = '';
          lastGoodQuery = '';
          lastGoodItems = [];
          return;
        }

        const myReq = ++activeSuggestReq;

        const fetchAndRender = async () => {
          try {
            // prefer matchup suggestions for 'vs' or '@'
            const looksMatchup = /\s(?:vs\.?|@|v)\s/i.test(text);
            const url = looksMatchup ? `/suggest-matchup?q=${encodeURIComponent(text)}&limit=15` : `/suggest?q=${encodeURIComponent(text)}&limit=15`;
            const res = await fetch(url, { headers: { 'accept': 'application/json' } });
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const data = await res.json();
            // ignore stale responses
            if (myReq !== activeSuggestReq) return;
            const items = (data.items || []).slice(0, 12);
            if ((items.length === 0) && lastGoodItems.length) {
              // keep previous good suggestions if this keystroke produced none
              renderSuggest(lastGoodItems);
            } else {
              renderSuggest(items);
              if (items.length) {
                lastGoodItems = items;
                lastGoodQuery = text;
              }
            }
          } catch (e) {
            // ignore errors for suggest, keep previous if any
          }
        };

        // quick probe + debounced confirm
        fetchAndRender();
        if (suggestTimer) clearTimeout(suggestTimer);
        suggestTimer = setTimeout(fetchAndRender, 120);
      });

      // keyboard navigation for suggestions
      q.addEventListener('keydown', (ev) => {
        if (sugg.style.display === 'none') return;
        const items = Array.from(sugg.querySelectorAll('.s-item'));
        if (!items.length) return;
        const idx = items.findIndex(n => n.classList.contains('active'));
        if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {
          ev.preventDefault();
          let ni = idx + (ev.key === 'ArrowDown' ? 1 : -1);
          if (ni < 0) ni = items.length-1; if (ni >= items.length) ni = 0;
          items.forEach(n => n.classList.remove('active')); items[ni].classList.add('active');
          items[ni].scrollIntoView({ block: 'nearest' });
        } else if (ev.key === 'Enter') {
          const active = items[idx >= 0 ? idx : 0];
          if (active) { active.dispatchEvent(new MouseEvent('mousedown')); }
        } else if (ev.key === 'Escape') {
          sugg.style.display = 'none';
        }
      });
      q.addEventListener('blur', () => { setTimeout(() => { sugg.style.display='none'; }, 150); });

      f.addEventListener('submit', (ev) => {
        ev.preventDefault();
        const text = (q.value || '').trim();
        if (!text) return;
        doSearch(text);
      });

      q.focus();
    </script>
  </body>
</html>



